## generated by RPythonic 0.3.6pre14
## http://code.google.com/p/rpythonic/
import os, sys, ctypes
IS32BIT = (ctypes.sizeof(ctypes.c_void_p)==4)

## this ctypes file expects to be in the cache directory, 
## with precompiled c-libraries two directories up, if the library is not there try to load from the system.
_clibs_dir = os.path.join( os.path.dirname(os.path.abspath(__file__)), '../../clibs' )
_clibs_dir = os.path.abspath( _clibs_dir )

def _load_ctypes_lib( name ):
	if os.name == 'posix':
		if sys.platform=='linux2':
			name += '.so'
			if IS32BIT: 	path = os.path.join(_clibs_dir,'linux32')
			else: 		path = os.path.join(_clibs_dir,'linux64')
			url = os.path.join( path, name )
			if os.path.isfile( url ): return ctypes.CDLL(url)
			elif os.path.isfile( '/usr/local/lib/%s'%name ): return ctypes.CDLL('/usr/local/lib/%s'%name)
			elif os.path.isfile( '/usr/local/lib64/%s'%name ) and not IS32BIT: return ctypes.CDLL('/usr/local/lib64/%s'%name)
			elif os.path.isfile( '/usr/lib/%s'%name ): return ctypes.CDLL('/usr/lib/%s'%name)
			elif os.path.isfile( './%s'%name ): return ctypes.CDLL('./%s'%name)
			else: return ctypes.CDLL(name) #fallback

		elif sys.platform == 'darwin':
			name += '.dylib'
			if IS32BIT: 	path = os.path.join(_clibs_dir,'osx32')
			else: 		path = os.path.join(_clibs_dir,'osx64')
			url = os.path.join( path, name )
			if os.path.isfile( url ): return ctypes.CDLL(url)
			else: return ctypes.CDLL(name) #fallback

	elif os.name == 'nt':
		name += '.dll'
		if IS32BIT: 	path = os.path.join(_clibs_dir,'win32')
		else: 		path = os.path.join(_clibs_dir,'win64')
		url = os.path.join( path, name )
		if os.path.isfile( url ): return ctypes.CDLL(url)
		else: return ctypes.CDLL(name) #fallback

RPYTHONIC_WRAPPER_FUNCTIONS = {}
RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES = []
RPYTHONIC_AUTOPREFIX_IGNORE = []

## ctypes does not clearly expose these types ##
PyCFuncPtrType = type(ctypes.CFUNCTYPE(ctypes.c_void_p))
PyCArrayType = type( ctypes.c_int * 2 )
PyCPointerType = type( ctypes.POINTER(ctypes.c_int) )
PyCStructType = type( ctypes.Structure )
CArgObject = type( ctypes.byref(ctypes.c_int()) )

class _rpythonic_meta_(object):
	_rpythonic_ = True		# workaround for now, must have a way to know if object is a meta from another module, isinstance(o,_rpythonic_meta_) will fail in those cases. another workaround could be check sys.modules for other rpythonic modules and fetch _rpythonic_meta_ from there.
	def __init__(self, *args, **kw ):	# cheap trick, abuse **kw, and look for "pointer"
		if 'pointer' in kw: self._pointer = kw['pointer']
		elif kw: raise SyntaxError	# sorry, you can not init with keywords
		else: self._pointer = ctypes.pointer( self._ctypes_struct_(*args) )
	def __getattr__(self,name):
		if hasattr( self._pointer.contents, name ):
			return getattr( self._pointer.contents, name )

		else:	# when rpythonic failed to generate good bindings - these lookups should be cached
			for parent in self._rpythonic_parent_classes_:
				if hasattr( parent, name ):
					method = getattr( parent, name )	# should check if it really is an unbound method
					#func = method._rpythonic_function_
					#return lambda *args: func( self, *args )	# what!, not self._pointer ??
					func = parent._rpythonic_unbound_lookup_[ method ]
					n = func.name
					if len(func.argnames) > 1:
						argnames = func.argnames[ 1 : ]
						a = ',' + '=None,'.join( argnames ) + '=None'
						b = ','.join( argnames )
					else: a = b = ''
					lamb = eval( 'lambda self %s: %s( self._pointer, %s )' %(a,n,b) )
					setattr( self.__class__, name, lamb )
					#return lamb	# this would return the unbound lambda, must call getattr again
					return getattr( self, name )

			## last resort, load from global name space ##
			G = globals()
			if name in G: return lambda *args: G[name](self._pointer, *args)
			else:
				for prefix in self._autoprefix_:
					n = prefix + name
					if n in G: return lambda *args: G[n](self._pointer, *args)
				print( 'possible auto-prefixes available', self._autoprefix_ )
				raise AttributeError

	def __call__(self, type=False):
		if type: return self._ctypes_struct_
		else: return self._pointer

PYTHON_RESERVED_KEYWORDS = 'for while in as global with try except lambda return raise if else elif eval exec and not or break continue finally print yield del def class assert'.split()


def _rpythonic_generate_subclass_( name, struct, functions ):
	head = 'class %s( _rpythonic_meta_ ):' %name
	body = [ 
		'_rpythonic_parent_classes_ = []' ,
		'_rpythonic_unbound_lookup_ = {}' 
	]

	names = [ func.name for func in functions ]

	possibles = {}
	rank = []		# rank by longest name
	for n1 in names:
		prefix = ''
		for i,char in enumerate(n1):
			prefix += char
			if prefix not in possibles:
				possibles[ prefix ] = 0
				for n2 in names:
					if n2.startswith( prefix ):
						possibles[ prefix ] += 1

				if not rank or len(prefix) > len(rank[-1]) and possibles[prefix] > len(names)/4:
					rank.append( prefix )

	top = []
	while rank:
		best = rank.pop()
		if possibles[best] > len(functions)/2 and best not in names:
			if best.endswith('_set_') or best.endswith('_get_'): best = best[ : -4 ]
			elif best.endswith('Set') or best.endswith('Get'): best = best[ : -3 ]

			rem = []
			for other in rank:
				if best.startswith(other): rem.append( other )
			for r in rem: rank.remove( r )

			if best not in top: top.append( best )

		if len(top) > 3: break

	for n in names:		# find shortest prefixes #
		prefix = ''
		for i,char in enumerate(n):		# cammelCase
			if i==0: prefix += char; continue
			if char.isupper() and len(prefix) >= 2: break
			prefix += char
		if prefix and prefix != n and len(prefix) >= 2:
			hits = 0
			for other in names:
				if other.startswith( prefix ): hits += 1
			if hits >= 2 and prefix not in top:
				top.append( prefix )
				if len(top) >= 6: break

	## setup full names
	for func in functions:
		n = func.name
		if len(func.argnames) > 1:
			argnames = func.argnames[ 1 : ]
			a = ',' + '=None,'.join( argnames ) + '=None'
			b = ','.join( argnames )
		else: a = b = ''

		fhead = 'def %s( self %s ):' %(n,a)
		fbody = ['return %s(self._pointer, %s)' %(func.name,b)]
		g = fhead + '\n\t\t' + '\n\t\t'.join( fbody )
		body.append( g )
		#body.append( '%s._rpythonic_function_ = %s' %(func.name, func.name) )

	## setup short names ##
	for n in names:
		for prefix in top:
			if n.startswith(prefix) and n[len(prefix):] not in names:
				alt = n[ len(prefix) : ]
				if alt and alt != n and alt not in PYTHON_RESERVED_KEYWORDS and not alt.isdigit() and not alt[0].isdigit():
					body.append( '%s = %s' %(alt,n) )
					names.append( alt )

	gen = head + '\n\t' + '\n\t'.join( body )
	try: exec( gen )
	except:
		print( gen )
		raise SyntaxError

	klass = locals()[name]
	klass._ctypes_struct_ = struct
	klass._autoprefix_ = top
	for func in functions:
		unbound = getattr( klass, func.name )
		klass._rpythonic_unbound_lookup_[ unbound ] = func
		# klass.longname is klass.shortname = False
		# klass.longname == klass.shortname = True
	return klass

def _rpythonic_convert_structs_to_objects():
	G = globals()
	for klass in _OOAPI_:
		altname = name = klass.__name__
		prefix = ''
		for i,char in enumerate(name):
			if i==0: prefix += char; continue
			if char.isupper(): break
			prefix += char
		if prefix and prefix != name:
			hits = 0
			for other in _OOAPI_:
				if other is not klass:
					if other.__name__.startswith( prefix ): hits += 1
			if hits >= 2:
				altname = name[ len(prefix) : ]

		funcs = _OOAPI_[ klass ]
		newklass = _rpythonic_generate_subclass_( altname, klass, funcs )
		klass._rpythonic_wrapper_class_ = newklass
		G[ name ] = newklass	# replace struct with wrapper
		if altname not in G: G[ altname ] = newklass	# safely define with nicer name
		elif altname != name: # odd cases, maybe a function that returns the object, almost never happens.
			print('WARN - not replacing something with struct wrapper:', G[altname] )


def _rpythonic_setup_return_wrappers():
	R = _rpythonic_function_
	for klass in _OOAPI_:
		if klass in _OOAPI_RETURNS_OBJECT_:
			for f in _OOAPI_RETURNS_OBJECT_[klass]:
				f.object_oriented = True
				if not f.return_wrapper:	# just in case the ctypes footer defines it
					f.return_wrapper = klass._rpythonic_wrapper_class_

def _rpythonic_function_( name, result=ctypes.c_void_p, args=[]):
	mname = '_metafunc_%s' %name
	exec( 'class %s( _rpythonic_metafunc_ ): pass' %mname )
	k = locals()[mname]
	return k( name, result, args )

_OOAPI_ = {}
_OOAPI_RETURNS_OBJECT_ = {}

class _rpythonic_metafunc_(object):
	def __init__(self, name, result=ctypes.c_void_p, args=[]):
		self.name = name
		self.result = result
		self.argtypes = []
		self.argnames = []
		self.argtypestypes = []
		for i,arg in enumerate(args):
			n,t = arg
			if n in PYTHON_RESERVED_KEYWORDS: n = 'C_'+n
			if n in self.argnames: n = '%s%s' %(n,i)
			self.argnames.append( n )
			self.argtypes.append( t )
			self.argtypestypes.append( type(t) )		# precomputed for speed
		self.argtypes = tuple( self.argtypes )
		self.argnames = tuple( self.argnames )
		self.argtypestypes = tuple( self.argtypestypes )
		self.numargs = len( self.argtypes )
		self.callbacks = [None] * self.numargs
		self.return_wrapper = None
		self.object_oriented = False
		self.function = None
		try:
			func = self.function = getattr(_ctypes_lib_, self.name )
			RPYTHONIC_WRAPPER_FUNCTIONS[ name ] = self
		except:
			RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES.append( name )
		if self.function: self.reset()


	def reset(self):
		if self.argnames:
			a = ',' + '=None,'.join( self.argnames ) + '=None'
			b = ','.join( self.argnames )
		else: a = b = ''

		callmeth = eval( 'lambda self %s: self._call_( %s )' %(a,b) )
		setattr( self.__class__, '__call__', callmeth )

		self.function.restype = self.result
		self.function.argtypes = self.argtypes

		if type( self.result ) is PyCPointerType and type(self.result._type_) is PyCStructType:
			klass = self.result._type_
			if klass not in _OOAPI_RETURNS_OBJECT_: _OOAPI_RETURNS_OBJECT_[klass] = []
			_OOAPI_RETURNS_OBJECT_[klass].append( self )

		self.defaults = []
		for i in range( self.numargs ):
			T = self.argtypes[ i ]
			if type(T) is PyCFuncPtrType:
				p = T()	# func pointers can not be None
				self.defaults.append( p )
				self.callbacks[ i ] = p					# save reference
			elif T in (ctypes.c_int, ctypes.c_uint, ctypes.c_long, ctypes.c_ulong):
				self.defaults.append( 0 )
			elif T in (ctypes.c_float, ctypes.c_double):
				self.defaults.append( .0 )
			else: self.defaults.append( None )	# None is allowed for all other types

			## generate OO API ##
			if i == 0 and type(T) is PyCPointerType and type(T._type_) is PyCStructType:
				klass = T._type_
				if klass not in _OOAPI_: _OOAPI_[ klass ] = []
				_OOAPI_[ klass ].append( self )

	def _call_( self, *args ):			# allow flexible calling types
		cargs = list( self.defaults )
		for i,arg in enumerate(args):
			if isinstance( arg, _rpythonic_meta_ ): arg = arg._pointer
			elif hasattr( arg, '_rpythonic_' ): arg = arg._pointer	# workaround

			t = type(arg)
			k = self.argtypes[ i ]
			kt = self.argtypestypes[ i ]
			if arg is None and cargs[i] is not None:	# use user defaults, very rare cases
				continue

			elif t is bool and k is ctypes.c_int:
				if arg: cargs[i] = 1	#ctypes.c_int(1)
				else: cargs[i] = 0	#ctypes.c_int(0)

			elif t in (list,tuple):				# convert lists and tuples into array
				if kt is PyCArrayType:
					cargs[ i ] = k(*arg)
				elif kt is PyCStructType:
					if k._array_wrapper_: cargs[ i ] = k(arg)	# allow easy array init
					else: cargs[ i ] = k(*arg)							# allow multiple args
				elif kt is PyCPointerType:
					cargs[ i ] = _convert_nested_list_to_pointer( k, arg )
				else: assert 0

			elif isinstance( arg, ctypes._Pointer ) and t is not k and kt is PyCPointerType:
				cargs[ i ] = ctypes.cast( arg, k )		# generic's that need to be cast

			elif kt is PyCStructType and isinstance( arg, ctypes._Pointer ):
				cargs[ i ] = arg.contents	# fixed may25

			elif kt is PyCPointerType and not isinstance( arg, (ctypes._Pointer,CArgObject) ):
				if t in (int,float,bool): ptr = k( k._type_(arg) )
				elif t is str:
					ptr = k( k._type_() )		# not k() otherwise null pointer error
					for j, char in enumerate(arg): ptr[ j ] = char.encode('ascii')
				elif t in (PyCStructType, PyCArrayType):
					ptr = ctypes.cast( ctypes.pointer( arg ), k )
				else: ptr = arg	# buggy TODO
				#else:		# wrap py object - not safe!!
				#	ptr = ctypes.cast( ctypes.pointer(ctypes.py_object(arg)), k )
				cargs[ i ] = ptr
			elif kt is PyCFuncPtrType:
				cargs[ i ] = self.callbacks[ i ] = k( arg )		# assume arg is a callable
			else:
				cargs[ i ] = arg		# directly pass

		## if you define your own return_wrapper, it must take argument pointer=...
		#print( cargs )
		if self.return_wrapper: return self.return_wrapper( pointer=self.function( *cargs ) )
		else: return self.function( *cargs )



def _convert_nested_list_to_pointer( k, arg ):
	depth = 0; s = k
	while True:
		if type(s) is PyCPointerType:
			s = getattr( s, '_type_' )
			depth += 1
		else: break
	assert depth and depth <= 2
	if depth == 1:
		T = k._type_
		ptr = k( k._type_() )
		for i in range( len(arg) ):
			ptr[ i ] = T( *arg[i] )
	elif depth == 2:
		T = k._type_._type_
		_ptr = k._type_( k._type_._type_() )
		for i in range(len( arg )):
			for j in range( len(arg[i]) ):
				_ptr[ j ] = T( *arg[ i ][ j ] )
		ptr = k( _ptr )
	return ptr


def __freeze_rpythonic_struct( cls, fields ):
	if cls not in _OOAPI_: _OOAPI_[ cls ] = []	# wrap all structs
	try: setattr( cls, '_fields_', fields )
	except:
		print( 'WARN - bad order struct freeze', cls )
		#cls._fields_ = []

class _rpythonic_struct_( ctypes.Structure ):
	_array_wrapper_ = False
	_fields_ = []
	_methods_ = {}
	def __call__(self): return self
	def __init__(self, *args, **kw ):
		cargs = []
		argtypes = []
		for a in self._fields_: argtypes.append( a[1] )
		if len(args) > len(argtypes): args = [args]	# allow both calling conventions
		for i,arg in enumerate( args ):
			if isinstance( arg, _rpythonic_meta_ ): arg = arg._pointer
			t = type(arg)
			k = argtypes[ i ]
			if t in (list,tuple):
				if k.__class__.__name__	== 'PyCArrayType':
					cargs.append( k(*arg) )
				elif k.__class__.__name__ == 'PyCStructType':
					if k._array_wrapper_: cargs.append( k(arg) )	# allow easy array init
					else: cargs.append( k(*arg) )							# allow multiple args
			elif isinstance( arg, ctypes._Pointer ) and t is not k:
				cargs[ i ] = ctypes.cast( arg, k )	# generic's that need to be cast
			elif k.__class__.__name__ == 'PyCArrayType' and t in (float,int,bool):
				cargs.append( k(arg) )		# support init array from single value
			else:
				cargs.append( arg )		# directly pass

		ctypes.Structure.__init__(self, *cargs, **kw)


def _rpythonic_make_nice_global_enums_():
	G = globals()
	for name in RPYTHONIC_GLOBAL_ENUMS:
		if '_' in name and name.index('_') <= 4:
			altname = name[ name.index('_') + 1 : ]
			if altname not in G:
				G[altname] = RPYTHONIC_GLOBAL_ENUMS[ name ]

def _rpythonic_clean_up_missing_functions_():
	G = globals()
	for f in RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES:
		G.pop( f )
	print( "C functions loaded: %s" %len(RPYTHONIC_WRAPPER_FUNCTIONS) )
	print( "C functions failed: %s" %len(RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES) )




_clib_name_ = 'libwiiuse'
print('loading lib', _clib_name_)
print( os.path.abspath( os.path.curdir ) )
_ctypes_lib_ = _load_ctypes_lib( _clib_name_ )
assert _ctypes_lib_
print( _ctypes_lib_._name )

## macro globals ##
WIIUSE_MAJOR = 0
WIIUSE_MINOR = 14
WIIUSE_MICRO = 0
WIIMOTE_LED_NONE = 0
WIIMOTE_LED_1 = 16
WIIMOTE_LED_2 = 32
WIIMOTE_LED_3 = 64
WIIMOTE_LED_4 = 128
WIIMOTE_BUTTON_TWO = 1
WIIMOTE_BUTTON_ONE = 2
WIIMOTE_BUTTON_B = 4
WIIMOTE_BUTTON_A = 8
WIIMOTE_BUTTON_MINUS = 16
WIIMOTE_BUTTON_ZACCEL_BIT6 = 32
WIIMOTE_BUTTON_ZACCEL_BIT7 = 64
WIIMOTE_BUTTON_HOME = 128
WIIMOTE_BUTTON_LEFT = 256
WIIMOTE_BUTTON_RIGHT = 512
WIIMOTE_BUTTON_DOWN = 1024
WIIMOTE_BUTTON_UP = 2048
WIIMOTE_BUTTON_PLUS = 4096
WIIMOTE_BUTTON_ZACCEL_BIT4 = 8192
WIIMOTE_BUTTON_ZACCEL_BIT5 = 16384
WIIMOTE_BUTTON_UNKNOWN = 32768
WIIMOTE_BUTTON_ALL = 8095
NUNCHUK_BUTTON_Z = 1
NUNCHUK_BUTTON_C = 2
NUNCHUK_BUTTON_ALL = 3
CLASSIC_CTRL_BUTTON_UP = 1
CLASSIC_CTRL_BUTTON_LEFT = 2
CLASSIC_CTRL_BUTTON_ZR = 4
CLASSIC_CTRL_BUTTON_X = 8
CLASSIC_CTRL_BUTTON_A = 16
CLASSIC_CTRL_BUTTON_Y = 32
CLASSIC_CTRL_BUTTON_B = 64
CLASSIC_CTRL_BUTTON_ZL = 128
CLASSIC_CTRL_BUTTON_FULL_R = 512
CLASSIC_CTRL_BUTTON_PLUS = 1024
CLASSIC_CTRL_BUTTON_HOME = 2048
CLASSIC_CTRL_BUTTON_MINUS = 4096
CLASSIC_CTRL_BUTTON_FULL_L = 8192
CLASSIC_CTRL_BUTTON_DOWN = 16384
CLASSIC_CTRL_BUTTON_RIGHT = 32768
CLASSIC_CTRL_BUTTON_ALL = 65279
GUITAR_HERO_3_BUTTON_STRUM_UP = 1
GUITAR_HERO_3_BUTTON_YELLOW = 8
GUITAR_HERO_3_BUTTON_GREEN = 16
GUITAR_HERO_3_BUTTON_BLUE = 32
GUITAR_HERO_3_BUTTON_RED = 64
GUITAR_HERO_3_BUTTON_ORANGE = 128
GUITAR_HERO_3_BUTTON_PLUS = 1024
GUITAR_HERO_3_BUTTON_MINUS = 4096
GUITAR_HERO_3_BUTTON_STRUM_DOWN = 16384
GUITAR_HERO_3_BUTTON_ALL = 65279
WIIUSE_SMOOTHING = 1
WIIUSE_CONTINUOUS = 2
WIIUSE_ORIENT_THRESH = 4
WIIUSE_ORIENT_PRECISION = 100.0
EXP_NONE = 0
EXP_NUNCHUK = 1
EXP_CLASSIC = 2
EXP_GUITAR_HERO_3 = 3
EXP_WII_BOARD = 4
MAX_PAYLOAD = 32
## enums ##
_socket_type = { 
	"SOCK_STREAM" : 1, 
	"SOCK_DGRAM" : 2, 
	"SOCK_RAW" : 3, 
	"SOCK_RDM" : 4, 
	"SOCK_SEQPACKET" : 5, 
	"SOCK_DCCP" : 6, 
	"SOCK_PACKET" : 10, 
	"SOCK_CLOEXEC" : 2000000, 
	"SOCK_NONBLOCK" : 4000, 
}

MSG_OOB = 1 
MSG_PEEK = 2 
MSG_DONTROUTE = 4 
MSG_CTRUNC = 8 
MSG_PROXY = 16 
MSG_TRUNC = 32 
MSG_DONTWAIT = 64 
MSG_EOR = 128 
MSG_WAITALL = 256 
MSG_FIN = 512 
MSG_SYN = 1024 
MSG_CONFIRM = 2048 
MSG_RST = 4096 
MSG_ERRQUEUE = 8192 
MSG_NOSIGNAL = 16384 
MSG_MORE = 32768 
MSG_WAITFORONE = 65536 
MSG_CMSG_CLOEXEC = 1073741824 

SCM_RIGHTS = 1 

SHUT_RD = 0 
SHUT_WR = 1 
SHUT_RDWR = 2 

wiiuse_loglevel = { 
	"LOGLEVEL_ERROR" : 0, 
	"LOGLEVEL_WARNING" : 1, 
	"LOGLEVEL_INFO" : 2, 
	"LOGLEVEL_DEBUG" : 3, 
}

WIIUSE_EVENT_TYPE = { 
	"WIIUSE_NONE" : 0, 
	"WIIUSE_EVENT" : 1, 
	"WIIUSE_STATUS" : 2, 
	"WIIUSE_CONNECT" : 3, 
	"WIIUSE_DISCONNECT" : 4, 
	"WIIUSE_UNEXPECTED_DISCONNECT" : 5, 
	"WIIUSE_READ_DATA" : 6, 
	"WIIUSE_NUNCHUK_INSERTED" : 7, 
	"WIIUSE_NUNCHUK_REMOVED" : 8, 
	"WIIUSE_CLASSIC_CTRL_INSERTED" : 9, 
	"WIIUSE_CLASSIC_CTRL_REMOVED" : 10, 
	"WIIUSE_GUITAR_HERO_3_CTRL_INSERTED" : 11, 
	"WIIUSE_GUITAR_HERO_3_CTRL_REMOVED" : 12, 
	"WIIUSE_WII_BOARD_CTRL_INSERTED" : 13, 
	"WIIUSE_WII_BOARD_CTRL_REMOVED" : 14, 
}

win_bt_stack_t = { 
	"WIIUSE_STACK_UNKNOWN" : 0, 
	"WIIUSE_STACK_MS" : 1, 
	"WIIUSE_STACK_BLUESOLEIL" : 2, 
}

aspect_t = { 
	"WIIUSE_ASPECT_4_3" : 0, 
	"WIIUSE_ASPECT_16_9" : 1, 
}

ir_position_t = { 
	"WIIUSE_IR_ABOVE" : 0, 
	"WIIUSE_IR_BELOW" : 1, 
}

BT_CONNECTED = 1 
BT_OPEN = 2 
BT_BOUND = 3 
BT_LISTEN = 4 
BT_CONNECT = 5 
BT_CONNECT2 = 6 
BT_CONFIG = 7 
BT_DISCONN = 8 
BT_CLOSED = 9 

IPPROTO_IP = 0 
IPPROTO_HOPOPTS = 0 
IPPROTO_ICMP = 1 
IPPROTO_IGMP = 2 
IPPROTO_IPIP = 4 
IPPROTO_TCP = 6 
IPPROTO_EGP = 8 
IPPROTO_PUP = 12 
IPPROTO_UDP = 17 
IPPROTO_IDP = 22 
IPPROTO_TP = 29 
IPPROTO_DCCP = 33 
IPPROTO_IPV6 = 41 
IPPROTO_ROUTING = 43 
IPPROTO_FRAGMENT = 44 
IPPROTO_RSVP = 46 
IPPROTO_GRE = 47 
IPPROTO_ESP = 50 
IPPROTO_AH = 51 
IPPROTO_ICMPV6 = 58 
IPPROTO_NONE = 59 
IPPROTO_DSTOPTS = 60 
IPPROTO_MTP = 92 
IPPROTO_ENCAP = 98 
IPPROTO_PIM = 103 
IPPROTO_COMP = 108 
IPPROTO_SCTP = 132 
IPPROTO_UDPLITE = 136 
IPPROTO_RAW = 255 
IPPROTO_MAX = 256 

IPPORT_ECHO = 7 
IPPORT_DISCARD = 9 
IPPORT_SYSTAT = 11 
IPPORT_DAYTIME = 13 
IPPORT_NETSTAT = 15 
IPPORT_FTP = 21 
IPPORT_TELNET = 23 
IPPORT_SMTP = 25 
IPPORT_TIMESERVER = 37 
IPPORT_NAMESERVER = 42 
IPPORT_WHOIS = 43 
IPPORT_MTP = 57 
IPPORT_TFTP = 69 
IPPORT_RJE = 77 
IPPORT_FINGER = 79 
IPPORT_TTYLINK = 87 
IPPORT_SUPDUP = 95 
IPPORT_EXECSERVER = 512 
IPPORT_LOGINSERVER = 513 
IPPORT_CMDSERVER = 514 
IPPORT_EFSSERVER = 520 
IPPORT_BIFFUDP = 512 
IPPORT_WHOSERVER = 513 
IPPORT_ROUTESERVER = 520 
IPPORT_RESERVED = 1024 
IPPORT_USERRESERVED = 5000 

_codecvt_result = { 
	"__codecvt_ok" : 0, 
	"__codecvt_partial" : 1, 
	"__codecvt_error" : 2, 
	"__codecvt_noconv" : 3, 
}

## simple enums ##
RPYTHONIC_GLOBAL_ENUMS = { 
 "MSG_OOB" : 1,  "MSG_PEEK" : 2,  "MSG_DONTROUTE" : 4,  "MSG_CTRUNC" : 8,  "MSG_PROXY" : 16,  "MSG_TRUNC" : 32,  "MSG_DONTWAIT" : 64,  "MSG_EOR" : 128,  "MSG_WAITALL" : 256,  "MSG_FIN" : 512,  "MSG_SYN" : 1024,  "MSG_CONFIRM" : 2048,  "MSG_RST" : 4096,  "MSG_ERRQUEUE" : 8192,  "MSG_NOSIGNAL" : 16384,  "MSG_MORE" : 32768,  "MSG_WAITFORONE" : 65536,  "MSG_CMSG_CLOEXEC" : 1073741824, 
 "SCM_RIGHTS" : 1, 
 "SHUT_RD" : 0,  "SHUT_WR" : 1,  "SHUT_RDWR" : 2, 
 "BT_CONNECTED" : 1,  "BT_OPEN" : 2,  "BT_BOUND" : 3,  "BT_LISTEN" : 4,  "BT_CONNECT" : 5,  "BT_CONNECT2" : 6,  "BT_CONFIG" : 7,  "BT_DISCONN" : 8,  "BT_CLOSED" : 9, 
 "IPPROTO_IP" : 0,  "IPPROTO_HOPOPTS" : 0,  "IPPROTO_ICMP" : 1,  "IPPROTO_IGMP" : 2,  "IPPROTO_IPIP" : 4,  "IPPROTO_TCP" : 6,  "IPPROTO_EGP" : 8,  "IPPROTO_PUP" : 12,  "IPPROTO_UDP" : 17,  "IPPROTO_IDP" : 22,  "IPPROTO_TP" : 29,  "IPPROTO_DCCP" : 33,  "IPPROTO_IPV6" : 41,  "IPPROTO_ROUTING" : 43,  "IPPROTO_FRAGMENT" : 44,  "IPPROTO_RSVP" : 46,  "IPPROTO_GRE" : 47,  "IPPROTO_ESP" : 50,  "IPPROTO_AH" : 51,  "IPPROTO_ICMPV6" : 58,  "IPPROTO_NONE" : 59,  "IPPROTO_DSTOPTS" : 60,  "IPPROTO_MTP" : 92,  "IPPROTO_ENCAP" : 98,  "IPPROTO_PIM" : 103,  "IPPROTO_COMP" : 108,  "IPPROTO_SCTP" : 132,  "IPPROTO_UDPLITE" : 136,  "IPPROTO_RAW" : 255,  "IPPROTO_MAX" : 256, 
 "IPPORT_ECHO" : 7,  "IPPORT_DISCARD" : 9,  "IPPORT_SYSTAT" : 11,  "IPPORT_DAYTIME" : 13,  "IPPORT_NETSTAT" : 15,  "IPPORT_FTP" : 21,  "IPPORT_TELNET" : 23,  "IPPORT_SMTP" : 25,  "IPPORT_TIMESERVER" : 37,  "IPPORT_NAMESERVER" : 42,  "IPPORT_WHOIS" : 43,  "IPPORT_MTP" : 57,  "IPPORT_TFTP" : 69,  "IPPORT_RJE" : 77,  "IPPORT_FINGER" : 79,  "IPPORT_TTYLINK" : 87,  "IPPORT_SUPDUP" : 95,  "IPPORT_EXECSERVER" : 512,  "IPPORT_LOGINSERVER" : 513,  "IPPORT_CMDSERVER" : 514,  "IPPORT_EFSSERVER" : 520,  "IPPORT_BIFFUDP" : 512,  "IPPORT_WHOSERVER" : 513,  "IPPORT_ROUTESERVER" : 520,  "IPPORT_RESERVED" : 1024,  "IPPORT_USERRESERVED" : 5000, 

}
class __fsid_t(_rpythonic_struct_): _array_wrapper_ = True
class __mbstate_t(_rpythonic_struct_): pass
class __value(ctypes.Union): pass
class _G_fpos_t(_rpythonic_struct_): pass
class _G_fpos64_t(_rpythonic_struct_): pass
class _IO_jump_t(_rpythonic_struct_): pass
class _IO_marker(_rpythonic_struct_): pass
class _IO_FILE(_rpythonic_struct_): _array_wrapper_ = True
class _IO_FILE_plus(_rpythonic_struct_): pass
class __locale_struct(_rpythonic_struct_): _array_wrapper_ = True
class __locale_data(_rpythonic_struct_): pass
class __sigset_t(_rpythonic_struct_): _array_wrapper_ = True
class timespec(_rpythonic_struct_): pass
class timeval(_rpythonic_struct_): pass
class fd_set(_rpythonic_struct_): _array_wrapper_ = True
class pthread_attr_t(ctypes.Union): pass
class __pthread_internal_slist(_rpythonic_struct_): pass
class pthread_mutex_t(ctypes.Union): pass
class __pthread_mutex_s(_rpythonic_struct_): pass
class pthread_mutexattr_t(ctypes.Union): pass
class pthread_cond_t(ctypes.Union): pass
class pthread_condattr_t(ctypes.Union): pass
class pthread_rwlock_t(ctypes.Union): pass
class __data(_rpythonic_struct_): pass
class pthread_rwlockattr_t(ctypes.Union): pass
class pthread_barrier_t(ctypes.Union): pass
class pthread_barrierattr_t(ctypes.Union): pass
class iovec(_rpythonic_struct_): pass
class sockaddr(_rpythonic_struct_): _array_wrapper_ = True
class sockaddr_storage(_rpythonic_struct_): _array_wrapper_ = True
class msghdr(_rpythonic_struct_): pass
class cmsghdr(_rpythonic_struct_): _array_wrapper_ = True
class linger(_rpythonic_struct_): pass
class mmsghdr(_rpythonic_struct_): pass
class osockaddr(_rpythonic_struct_): _array_wrapper_ = True
class in_addr(_rpythonic_struct_): pass
class in6_addr(_rpythonic_struct_): pass
class __in6_u(ctypes.Union): pass
class sockaddr_in(_rpythonic_struct_): _array_wrapper_ = True
class sockaddr_in6(_rpythonic_struct_): pass
class ip_mreq(_rpythonic_struct_): pass
class ip_mreq_source(_rpythonic_struct_): pass
class ipv6_mreq(_rpythonic_struct_): pass
class group_req(_rpythonic_struct_): pass
class group_source_req(_rpythonic_struct_): pass
class ip_msfilter(_rpythonic_struct_): _array_wrapper_ = True
class group_filter(_rpythonic_struct_): _array_wrapper_ = True
class ip_opts(_rpythonic_struct_): _array_wrapper_ = True
class ip_mreqn(_rpythonic_struct_): pass
class in_pktinfo(_rpythonic_struct_): pass
class bt_security(_rpythonic_struct_): pass
class bdaddr_t(_rpythonic_struct_): _array_wrapper_ = True
class uint128_t(_rpythonic_struct_): _array_wrapper_ = True
class read_req_t(_rpythonic_struct_): pass
class vec2b_t(_rpythonic_struct_): pass
class vec3b_t(_rpythonic_struct_): pass
class vec3f_t(_rpythonic_struct_): pass
class orient_t(_rpythonic_struct_): pass
class gforce_t(_rpythonic_struct_): pass
class accel_t(_rpythonic_struct_): pass
class ir_dot_t(_rpythonic_struct_): pass
class ir_t(_rpythonic_struct_): _array_wrapper_ = True
class joystick_t(_rpythonic_struct_): pass
class nunchuk_t(_rpythonic_struct_): pass
class classic_ctrl_t(_rpythonic_struct_): pass
class guitar_hero_3_t(_rpythonic_struct_): pass
class wii_board_t(_rpythonic_struct_): _array_wrapper_ = True
class expansion_t(_rpythonic_struct_): pass
class wiimote_state_t(_rpythonic_struct_): pass
class wiimote_t(_rpythonic_struct_): _array_wrapper_ = True
class WiimoteState_t(_rpythonic_struct_): pass
## union and structures ##
__freeze_rpythonic_struct( __fsid_t, [
	( "__val", ( ctypes.c_int * 2 ) ),
])

__freeze_rpythonic_struct( __value, [
	( "__wch", ctypes.c_uint ),
	( "__wchb", ( ctypes.c_char * 4 ) ),
])

__freeze_rpythonic_struct( __mbstate_t, [
	( "__count", ctypes.c_int ),
	( "__value", __value ),
])

__freeze_rpythonic_struct( _G_fpos_t, [
	( "__pos", ctypes.c_int64 ),
	( "__state", __mbstate_t ),
])

__freeze_rpythonic_struct( _G_fpos64_t, [
	( "__pos", ctypes.c_longlong ),
	( "__state", __mbstate_t ),
])

__freeze_rpythonic_struct( _IO_jump_t, [
])

__freeze_rpythonic_struct( _IO_marker, [
	( "_next", ctypes.POINTER(_IO_marker) ),
	( "_sbuf", ctypes.POINTER(_IO_FILE) ),
	( "_pos", ctypes.c_int ),
])

__freeze_rpythonic_struct( _IO_FILE, [
	( "_flags", ctypes.c_int ),
	( "_IO_read_ptr", ctypes.POINTER(ctypes.c_char) ),
	( "_IO_read_end", ctypes.POINTER(ctypes.c_char) ),
	( "_IO_read_base", ctypes.POINTER(ctypes.c_char) ),
	( "_IO_write_base", ctypes.POINTER(ctypes.c_char) ),
	( "_IO_write_ptr", ctypes.POINTER(ctypes.c_char) ),
	( "_IO_write_end", ctypes.POINTER(ctypes.c_char) ),
	( "_IO_buf_base", ctypes.POINTER(ctypes.c_char) ),
	( "_IO_buf_end", ctypes.POINTER(ctypes.c_char) ),
	( "_IO_save_base", ctypes.POINTER(ctypes.c_char) ),
	( "_IO_backup_base", ctypes.POINTER(ctypes.c_char) ),
	( "_IO_save_end", ctypes.POINTER(ctypes.c_char) ),
	( "_markers", ctypes.POINTER(_IO_marker) ),
	( "_chain", ctypes.POINTER(_IO_FILE) ),
	( "_fileno", ctypes.c_int ),
	( "_flags2", ctypes.c_int ),
	( "_old_offset", ctypes.c_int64 ),
	( "_cur_column", ctypes.c_ushort ),
	( "_vtable_offset", ctypes.c_char ),
	( "_shortbuf", ( ctypes.c_char * 1 ) ),
	( "_lock", ctypes.POINTER(ctypes.c_void_p) ),
	( "_offset", ctypes.c_longlong ),
	( "__pad1", ctypes.POINTER(ctypes.c_void_p) ),
	( "__pad2", ctypes.POINTER(ctypes.c_void_p) ),
	( "__pad3", ctypes.POINTER(ctypes.c_void_p) ),
	( "__pad4", ctypes.POINTER(ctypes.c_void_p) ),
	( "__pad5", ctypes.c_uint ),
	( "_mode", ctypes.c_int ),
	( "_unused2", ctypes.c_char ),
])

__freeze_rpythonic_struct( _IO_FILE_plus, [
])

__freeze_rpythonic_struct( __locale_data, [
])

__freeze_rpythonic_struct( __locale_struct, [
	( "__locales", ctypes.POINTER(( __locale_data * 13 )) ),
	( "__ctype_b", ctypes.POINTER(ctypes.c_uint16) ),
	( "__ctype_tolower", ctypes.POINTER(ctypes.c_int) ),
	( "__ctype_toupper", ctypes.POINTER(ctypes.c_int) ),
	( "__names", ctypes.POINTER(( ctypes.c_char * 13 )) ),
])

__freeze_rpythonic_struct( __sigset_t, [
	( "__val", ctypes.c_uint64 ),
])

__freeze_rpythonic_struct( timespec, [
	( "tv_sec", ctypes.c_int64 ),
	( "tv_nsec", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( timeval, [
	( "tv_sec", ctypes.c_int64 ),
	( "tv_usec", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( fd_set, [
	( "__fds_bits", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( pthread_attr_t, [
	( "__size", ( ctypes.c_char * 36 ) ),
	( "__align", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( __pthread_internal_slist, [
	( "__next", ctypes.POINTER(__pthread_internal_slist) ),
])

__freeze_rpythonic_struct( __pthread_mutex_s, [
	( "__lock", ctypes.c_int ),
	( "__count", ctypes.c_uint ),
	( "__owner", ctypes.c_int ),
	( "__kind", ctypes.c_int ),
	( "__nusers", ctypes.c_uint ),
	#opaque-warning# <rpythonic.rpythonic.SomeThing object at 0xe57d78c>
])

__freeze_rpythonic_struct( pthread_mutex_t, [
	( "__data", __pthread_mutex_s ),
	( "__size", ( ctypes.c_char * 24 ) ),
	( "__align", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( pthread_mutexattr_t, [
	( "__size", ( ctypes.c_char * 4 ) ),
	( "__align", ctypes.c_int ),
])

__freeze_rpythonic_struct( __data, [
	( "__lock", ctypes.c_int ),
	( "__nr_readers", ctypes.c_uint ),
	( "__readers_wakeup", ctypes.c_uint ),
	( "__writer_wakeup", ctypes.c_uint ),
	( "__nr_readers_queued", ctypes.c_uint ),
	( "__nr_writers_queued", ctypes.c_uint ),
	( "__flags", ctypes.c_ubyte ),
	( "__shared", ctypes.c_ubyte ),
	( "__pad1", ctypes.c_ubyte ),
	( "__pad2", ctypes.c_ubyte ),
	( "__writer", ctypes.c_int ),
])

__freeze_rpythonic_struct( pthread_cond_t, [
	( "__data", __data ),
	( "__size", ( ctypes.c_char * 48 ) ),
	( "__align", ctypes.c_longlong ),
])

__freeze_rpythonic_struct( pthread_condattr_t, [
	( "__size", ( ctypes.c_char * 4 ) ),
	( "__align", ctypes.c_int ),
])

__freeze_rpythonic_struct( pthread_rwlock_t, [
	( "__data", __data ),
	( "__size", ( ctypes.c_char * 32 ) ),
	( "__align", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( pthread_rwlockattr_t, [
	( "__size", ( ctypes.c_char * 8 ) ),
	( "__align", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( pthread_barrier_t, [
	( "__size", ( ctypes.c_char * 20 ) ),
	( "__align", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( pthread_barrierattr_t, [
	( "__size", ( ctypes.c_char * 4 ) ),
	( "__align", ctypes.c_int ),
])

__freeze_rpythonic_struct( iovec, [
	( "iov_base", ctypes.POINTER(ctypes.c_void_p) ),
	( "iov_len", ctypes.c_uint ),
])

__freeze_rpythonic_struct( sockaddr, [
	( "sa_family", ctypes.c_uint16 ),
	( "sa_data", ( ctypes.c_char * 14 ) ),
])

__freeze_rpythonic_struct( sockaddr_storage, [
	( "ss_family", ctypes.c_uint16 ),
	( "__ss_align", ctypes.c_uint64 ),
	( "__ss_padding", ctypes.c_char ),
])

__freeze_rpythonic_struct( msghdr, [
	( "msg_name", ctypes.POINTER(ctypes.c_void_p) ),
	( "msg_namelen", ctypes.c_uint ),
	( "msg_iov", ctypes.POINTER(iovec) ),
	( "msg_iovlen", ctypes.c_uint ),
	( "msg_control", ctypes.POINTER(ctypes.c_void_p) ),
	( "msg_controllen", ctypes.c_uint ),
	( "msg_flags", ctypes.c_int ),
])

__freeze_rpythonic_struct( cmsghdr, [
	( "cmsg_len", ctypes.c_uint ),
	( "cmsg_level", ctypes.c_int ),
	( "cmsg_type", ctypes.c_int ),
	( "__cmsg_data", ctypes.c_ubyte ),
])

__freeze_rpythonic_struct( linger, [
	( "l_onoff", ctypes.c_int ),
	( "l_linger", ctypes.c_int ),
])

__freeze_rpythonic_struct( mmsghdr, [
])

__freeze_rpythonic_struct( osockaddr, [
	( "sa_family", ctypes.c_uint16 ),
	( "sa_data", ( ctypes.c_ubyte * 14 ) ),
])

__freeze_rpythonic_struct( in_addr, [
	( "s_addr", ctypes.c_uint32 ),
])

__freeze_rpythonic_struct( __in6_u, [
	( "__u6_addr8", ( ctypes.c_uint8 * 16 ) ),
	( "__u6_addr16", ( ctypes.c_uint16 * 8 ) ),
	( "__u6_addr32", ( ctypes.c_uint32 * 4 ) ),
])

__freeze_rpythonic_struct( in6_addr, [
	( "__in6_u", __in6_u ),
])

__freeze_rpythonic_struct( sockaddr_in, [
	( "sin_family", ctypes.c_uint16 ),
	( "sin_port", ctypes.c_uint16 ),
	( "sin_addr", in_addr ),
	( "sin_zero", ctypes.c_ubyte ),
])

__freeze_rpythonic_struct( sockaddr_in6, [
	( "sin6_family", ctypes.c_uint16 ),
	( "sin6_port", ctypes.c_uint16 ),
	( "sin6_flowinfo", ctypes.c_uint32 ),
	( "sin6_addr", in6_addr ),
	( "sin6_scope_id", ctypes.c_uint32 ),
])

__freeze_rpythonic_struct( ip_mreq, [
	( "imr_multiaddr", in_addr ),
	( "imr_interface", in_addr ),
])

__freeze_rpythonic_struct( ip_mreq_source, [
	( "imr_multiaddr", in_addr ),
	( "imr_interface", in_addr ),
	( "imr_sourceaddr", in_addr ),
])

__freeze_rpythonic_struct( ipv6_mreq, [
	( "ipv6mr_multiaddr", in6_addr ),
	( "ipv6mr_interface", ctypes.c_uint ),
])

__freeze_rpythonic_struct( group_req, [
	( "gr_interface", ctypes.c_uint32 ),
	( "gr_group", sockaddr_storage ),
])

__freeze_rpythonic_struct( group_source_req, [
	( "gsr_interface", ctypes.c_uint32 ),
	( "gsr_group", sockaddr_storage ),
	( "gsr_source", sockaddr_storage ),
])

__freeze_rpythonic_struct( ip_msfilter, [
	( "imsf_multiaddr", in_addr ),
	( "imsf_interface", in_addr ),
	( "imsf_fmode", ctypes.c_uint32 ),
	( "imsf_numsrc", ctypes.c_uint32 ),
	( "imsf_slist", ( in_addr * 1 ) ),
])

__freeze_rpythonic_struct( group_filter, [
	( "gf_interface", ctypes.c_uint32 ),
	( "gf_group", sockaddr_storage ),
	( "gf_fmode", ctypes.c_uint32 ),
	( "gf_numsrc", ctypes.c_uint32 ),
	( "gf_slist", ( sockaddr_storage * 1 ) ),
])

__freeze_rpythonic_struct( ip_opts, [
	( "ip_dst", in_addr ),
	( "ip_opts", ( ctypes.c_char * 40 ) ),
])

__freeze_rpythonic_struct( ip_mreqn, [
	( "imr_multiaddr", in_addr ),
	( "imr_address", in_addr ),
	( "imr_ifindex", ctypes.c_int ),
])

__freeze_rpythonic_struct( in_pktinfo, [
	( "ipi_ifindex", ctypes.c_int ),
	( "ipi_spec_dst", in_addr ),
	( "ipi_addr", in_addr ),
])

__freeze_rpythonic_struct( bt_security, [
	( "level", ctypes.c_uint8 ),
])

__freeze_rpythonic_struct( bdaddr_t, [
	( "b", ( ctypes.c_uint8 * 6 ) ),
])

__freeze_rpythonic_struct( uint128_t, [
	( "data", ( ctypes.c_uint8 * 16 ) ),
])

__freeze_rpythonic_struct( read_req_t, [
	( "cb", ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.POINTER(wiimote_t),ctypes.POINTER(ctypes.c_ubyte),ctypes.c_uint16,) ),
	( "buf", ctypes.POINTER(ctypes.c_ubyte) ),
	( "addr", ctypes.c_uint32 ),
	( "size", ctypes.c_uint16 ),
	( "wait", ctypes.c_uint16 ),
	( "dirty", ctypes.c_ubyte ),
	( "next", ctypes.POINTER(read_req_t) ),
])

__freeze_rpythonic_struct( vec2b_t, [
	( "x", ctypes.c_ubyte ),
	( "y", ctypes.c_ubyte ),
])

__freeze_rpythonic_struct( vec3b_t, [
	( "x", ctypes.c_ubyte ),
	( "y", ctypes.c_ubyte ),
	( "z", ctypes.c_ubyte ),
])

__freeze_rpythonic_struct( vec3f_t, [
	( "x", ctypes.c_float ),
	( "y", ctypes.c_float ),
	( "z", ctypes.c_float ),
])

__freeze_rpythonic_struct( orient_t, [
	( "roll", ctypes.c_float ),
	( "pitch", ctypes.c_float ),
	( "yaw", ctypes.c_float ),
	( "a_roll", ctypes.c_float ),
	( "a_pitch", ctypes.c_float ),
])

__freeze_rpythonic_struct( gforce_t, [
	( "x", ctypes.c_float ),
	( "y", ctypes.c_float ),
	( "z", ctypes.c_float ),
])

__freeze_rpythonic_struct( accel_t, [
	( "cal_zero", vec3b_t ),
	( "cal_g", vec3b_t ),
	( "st_roll", ctypes.c_float ),
	( "st_pitch", ctypes.c_float ),
	( "st_alpha", ctypes.c_float ),
])

__freeze_rpythonic_struct( ir_dot_t, [
	( "visible", ctypes.c_ubyte ),
	( "x", ctypes.c_uint ),
	( "y", ctypes.c_uint ),
	( "rx", ctypes.c_int16 ),
	( "ry", ctypes.c_int16 ),
	( "order", ctypes.c_ubyte ),
	( "size", ctypes.c_ubyte ),
])

__freeze_rpythonic_struct( ir_t, [
	( "dot", ( ir_dot_t * 4 ) ),
	( "num_dots", ctypes.c_ubyte ),
	( "aspect", ctypes.c_int ),
	( "pos", ctypes.c_int ),
	( "vres", ( ctypes.c_uint * 2 ) ),
	( "offset", ( ctypes.c_int * 2 ) ),
	( "state", ctypes.c_int ),
	( "ax", ctypes.c_int ),
	( "ay", ctypes.c_int ),
	( "x", ctypes.c_int ),
	( "y", ctypes.c_int ),
	( "distance", ctypes.c_float ),
	( "z", ctypes.c_float ),
])

__freeze_rpythonic_struct( joystick_t, [
	( "max", vec2b_t ),
	( "min", vec2b_t ),
	( "center", vec2b_t ),
	( "ang", ctypes.c_float ),
	( "mag", ctypes.c_float ),
])

__freeze_rpythonic_struct( nunchuk_t, [
	( "accel_calib", accel_t ),
	( "js", joystick_t ),
	( "flags", ctypes.POINTER(ctypes.c_int) ),
	( "btns", ctypes.c_ubyte ),
	( "btns_held", ctypes.c_ubyte ),
	( "btns_released", ctypes.c_ubyte ),
	( "orient_threshold", ctypes.c_float ),
	( "accel_threshold", ctypes.c_int ),
	( "accel", vec3b_t ),
	( "orient", orient_t ),
	( "gforce", gforce_t ),
])

__freeze_rpythonic_struct( classic_ctrl_t, [
	( "btns", ctypes.c_int16 ),
	( "btns_held", ctypes.c_int16 ),
	( "btns_released", ctypes.c_int16 ),
	( "r_shoulder", ctypes.c_float ),
	( "l_shoulder", ctypes.c_float ),
	( "ljs", joystick_t ),
	( "rjs", joystick_t ),
])

__freeze_rpythonic_struct( guitar_hero_3_t, [
	( "btns", ctypes.c_int16 ),
	( "btns_held", ctypes.c_int16 ),
	( "btns_released", ctypes.c_int16 ),
	( "whammy_bar", ctypes.c_float ),
	( "js", joystick_t ),
])

__freeze_rpythonic_struct( wii_board_t, [
	( "tl", ctypes.c_float ),
	( "tr", ctypes.c_float ),
	( "bl", ctypes.c_float ),
	( "br", ctypes.c_float ),
	( "rtl", ctypes.c_uint16 ),
	( "rtr", ctypes.c_uint16 ),
	( "rbl", ctypes.c_uint16 ),
	( "rbr", ctypes.c_uint16 ),
	( "ctl", ( ctypes.c_uint16 * 3 ) ),
	( "ctr", ( ctypes.c_uint16 * 3 ) ),
	( "cbl", ( ctypes.c_uint16 * 3 ) ),
	( "cbr", ( ctypes.c_uint16 * 3 ) ),
	( "update_calib", ctypes.c_uint8 ),
])

__freeze_rpythonic_struct( expansion_t, [
	( "C_type", ctypes.c_int ),
	#opaque-warning# <rpythonic.rpythonic.SomeThing object at 0x137ddc0c>
])

__freeze_rpythonic_struct( wiimote_state_t, [
	( "exp_ljs_ang", ctypes.c_float ),
	( "exp_rjs_ang", ctypes.c_float ),
	( "exp_ljs_mag", ctypes.c_float ),
	( "exp_rjs_mag", ctypes.c_float ),
	( "exp_btns", ctypes.c_uint16 ),
	( "exp_orient", orient_t ),
	( "exp_accel", vec3b_t ),
	( "exp_r_shoulder", ctypes.c_float ),
	( "exp_l_shoulder", ctypes.c_float ),
	( "exp_wb_rtr", ctypes.c_uint16 ),
	( "exp_wb_rtl", ctypes.c_uint16 ),
	( "exp_wb_rbr", ctypes.c_uint16 ),
	( "exp_wb_rbl", ctypes.c_uint16 ),
	( "ir_ax", ctypes.c_int ),
	( "ir_ay", ctypes.c_int ),
	( "ir_distance", ctypes.c_float ),
	( "orient", orient_t ),
	( "btns", ctypes.c_uint16 ),
	( "accel", vec3b_t ),
])

__freeze_rpythonic_struct( wiimote_t, [
	( "unid", ctypes.c_int ),
	( "bdaddr", bdaddr_t ),
	( "bdaddr_str", ( ctypes.c_char * 18 ) ),
	( "out_sock", ctypes.c_int ),
	( "in_sock", ctypes.c_int ),
	( "state", ctypes.c_int ),
	( "leds", ctypes.c_ubyte ),
	( "battery_level", ctypes.c_float ),
	( "flags", ctypes.c_int ),
	( "handshake_state", ctypes.c_ubyte ),
	( "read_req", ctypes.POINTER(read_req_t) ),
	( "accel_calib", accel_t ),
	( "exp", expansion_t ),
	( "accel", vec3b_t ),
	( "orient", orient_t ),
	( "gforce", gforce_t ),
	( "ir", ir_t ),
	( "btns", ctypes.c_uint16 ),
	( "btns_held", ctypes.c_uint16 ),
	( "btns_released", ctypes.c_uint16 ),
	( "orient_threshold", ctypes.c_float ),
	( "accel_threshold", ctypes.c_int32 ),
	( "lstate", wiimote_state_t ),
	( "event", ctypes.c_int ),
	( "event_buf", ( ctypes.c_ubyte * 32 ) ),
])

__freeze_rpythonic_struct( WiimoteState_t, [
	( "uid", ctypes.c_int ),
	( "leds", ctypes.c_ubyte ),
	( "battery_level", ctypes.c_float ),
	( "accel", vec3b_t ),
	( "orient", orient_t ),
	( "gforce", gforce_t ),
	( "ir", ir_t ),
	( "buttons", ctypes.c_uint16 ),
	( "buttons_held", ctypes.c_uint16 ),
	( "buttons_released", ctypes.c_uint16 ),
	( "event", ctypes.c_int ),
	( "state", ctypes.c_int ),
	( "expansion", expansion_t ),
])

## wrapper functions ##
strncat = _rpythonic_function_(		"strncat", ctypes.POINTER(ctypes.c_char), [
	("__dest",		ctypes.POINTER(ctypes.c_char)),
	("__src",		ctypes.POINTER(ctypes.c_char)),
	("__n",		ctypes.c_uint),] )

strcmp = _rpythonic_function_(		"strcmp", ctypes.c_int, [
	("__s1",		ctypes.POINTER(ctypes.c_char)),
	("__s2",		ctypes.POINTER(ctypes.c_char)),] )

strncmp = _rpythonic_function_(		"strncmp", ctypes.c_int, [
	("__s1",		ctypes.POINTER(ctypes.c_char)),
	("__s2",		ctypes.POINTER(ctypes.c_char)),
	("__n",		ctypes.c_uint),] )

strcoll = _rpythonic_function_(		"strcoll", ctypes.c_int, [
	("__s1",		ctypes.POINTER(ctypes.c_char)),
	("__s2",		ctypes.POINTER(ctypes.c_char)),] )

strxfrm = _rpythonic_function_(		"strxfrm", ctypes.c_uint, [
	("__dest",		ctypes.POINTER(ctypes.c_char)),
	("__src",		ctypes.POINTER(ctypes.c_char)),
	("__n",		ctypes.c_uint),] )

strcoll_l = _rpythonic_function_(		"strcoll_l", ctypes.c_int, [
	("__s1",		ctypes.POINTER(ctypes.c_char)),
	("__s2",		ctypes.POINTER(ctypes.c_char)),
	("__l",		ctypes.POINTER(__locale_struct)),] )

strxfrm_l = _rpythonic_function_(		"strxfrm_l", ctypes.c_uint, [
	("__dest",		ctypes.POINTER(ctypes.c_char)),
	("__src",		ctypes.POINTER(ctypes.c_char)),
	("__n",		ctypes.c_uint),
	("__l",		ctypes.POINTER(__locale_struct)),] )

strdup = _rpythonic_function_(		"strdup", ctypes.POINTER(ctypes.c_char), [
	("__s",		ctypes.POINTER(ctypes.c_char)),] )

strndup = _rpythonic_function_(		"strndup", ctypes.POINTER(ctypes.c_char), [
	("__string",		ctypes.POINTER(ctypes.c_char)),
	("__n",		ctypes.c_uint),] )

strchr = _rpythonic_function_(		"strchr", ctypes.POINTER(ctypes.c_char), [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__c",		ctypes.c_int),] )

strrchr = _rpythonic_function_(		"strrchr", ctypes.POINTER(ctypes.c_char), [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__c",		ctypes.c_int),] )

strcspn = _rpythonic_function_(		"strcspn", ctypes.c_uint, [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__reject",		ctypes.POINTER(ctypes.c_char)),] )

strspn = _rpythonic_function_(		"strspn", ctypes.c_uint, [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__accept",		ctypes.POINTER(ctypes.c_char)),] )

strpbrk = _rpythonic_function_(		"strpbrk", ctypes.POINTER(ctypes.c_char), [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__accept",		ctypes.POINTER(ctypes.c_char)),] )

strstr = _rpythonic_function_(		"strstr", ctypes.POINTER(ctypes.c_char), [
	("__haystack",		ctypes.POINTER(ctypes.c_char)),
	("__needle",		ctypes.POINTER(ctypes.c_char)),] )

strtok = _rpythonic_function_(		"strtok", ctypes.POINTER(ctypes.c_char), [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__delim",		ctypes.POINTER(ctypes.c_char)),] )

strtok_r = _rpythonic_function_(		"strtok_r", ctypes.POINTER(ctypes.c_char), [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__delim",		ctypes.POINTER(ctypes.c_char)),
	("__save_ptr",		ctypes.POINTER(ctypes.POINTER(ctypes.c_char))),] )

strlen = _rpythonic_function_(		"strlen", ctypes.c_uint, [
	("__s",		ctypes.POINTER(ctypes.c_char)),] )

strnlen = _rpythonic_function_(		"strnlen", ctypes.c_uint, [
	("__string",		ctypes.POINTER(ctypes.c_char)),
	("__maxlen",		ctypes.c_uint),] )

strerror = _rpythonic_function_(		"strerror", ctypes.POINTER(ctypes.c_char), [
	("__errnum",		ctypes.c_int),] )

strerror_r = _rpythonic_function_(		"strerror_r", ctypes.c_int, [
	("__errnum",		ctypes.c_int),
	("__buf",		ctypes.POINTER(ctypes.c_char)),
	("__buflen",		ctypes.c_uint),] )

memset = _rpythonic_function_(		"memset", ctypes.POINTER(ctypes.c_void_p), [
	("__s",		ctypes.POINTER(ctypes.c_void_p)),
	("__c",		ctypes.c_int),
	("__n",		ctypes.c_uint),] )

memcmp = _rpythonic_function_(		"memcmp", ctypes.c_int, [
	("__s1",		ctypes.POINTER(ctypes.c_void_p)),
	("__s2",		ctypes.POINTER(ctypes.c_void_p)),
	("__n",		ctypes.c_uint),] )

memchr = _rpythonic_function_(		"memchr", ctypes.POINTER(ctypes.c_void_p), [
	("__s",		ctypes.POINTER(ctypes.c_void_p)),
	("__c",		ctypes.c_int),
	("__n",		ctypes.c_uint),] )

strcpy = _rpythonic_function_(		"strcpy", ctypes.POINTER(ctypes.c_char), [
	("__dest",		ctypes.POINTER(ctypes.c_char)),
	("__src",		ctypes.POINTER(ctypes.c_char)),] )

strncpy = _rpythonic_function_(		"strncpy", ctypes.POINTER(ctypes.c_char), [
	("__dest",		ctypes.POINTER(ctypes.c_char)),
	("__src",		ctypes.POINTER(ctypes.c_char)),
	("__n",		ctypes.c_uint),] )

strcat = _rpythonic_function_(		"strcat", ctypes.POINTER(ctypes.c_char), [
	("__dest",		ctypes.POINTER(ctypes.c_char)),
	("__src",		ctypes.POINTER(ctypes.c_char)),] )

strerror_l = _rpythonic_function_(		"strerror_l", ctypes.POINTER(ctypes.c_char), [
	("__errnum",		ctypes.c_int),
	("__l",		ctypes.POINTER(__locale_struct)),] )

bcopy = _rpythonic_function_(		"bcopy", ctypes.c_void_p, [
	("__src",		ctypes.POINTER(ctypes.c_void_p)),
	("__dest",		ctypes.POINTER(ctypes.c_void_p)),
	("__n",		ctypes.c_uint),] )

bzero = _rpythonic_function_(		"bzero", ctypes.c_void_p, [
	("__s",		ctypes.POINTER(ctypes.c_void_p)),
	("__n",		ctypes.c_uint),] )

bcmp = _rpythonic_function_(		"bcmp", ctypes.c_int, [
	("__s1",		ctypes.POINTER(ctypes.c_void_p)),
	("__s2",		ctypes.POINTER(ctypes.c_void_p)),
	("__n",		ctypes.c_uint),] )

index = _rpythonic_function_(		"index", ctypes.POINTER(ctypes.c_char), [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__c",		ctypes.c_int),] )

rindex = _rpythonic_function_(		"rindex", ctypes.POINTER(ctypes.c_char), [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__c",		ctypes.c_int),] )

ffs = _rpythonic_function_(		"ffs", ctypes.c_int, [
	("__i",		ctypes.c_int),] )

strcasecmp = _rpythonic_function_(		"strcasecmp", ctypes.c_int, [
	("__s1",		ctypes.POINTER(ctypes.c_char)),
	("__s2",		ctypes.POINTER(ctypes.c_char)),] )

strncasecmp = _rpythonic_function_(		"strncasecmp", ctypes.c_int, [
	("__s1",		ctypes.POINTER(ctypes.c_char)),
	("__s2",		ctypes.POINTER(ctypes.c_char)),
	("__n",		ctypes.c_uint),] )

strsep = _rpythonic_function_(		"strsep", ctypes.POINTER(ctypes.c_char), [
	("__stringp",		ctypes.POINTER(ctypes.POINTER(ctypes.c_char))),
	("__delim",		ctypes.POINTER(ctypes.c_char)),] )

strsignal = _rpythonic_function_(		"strsignal", ctypes.POINTER(ctypes.c_char), [
	("__sig",		ctypes.c_int),] )

stpcpy = _rpythonic_function_(		"stpcpy", ctypes.POINTER(ctypes.c_char), [
	("__dest",		ctypes.POINTER(ctypes.c_char)),
	("__src",		ctypes.POINTER(ctypes.c_char)),] )

stpncpy = _rpythonic_function_(		"stpncpy", ctypes.POINTER(ctypes.c_char), [
	("__dest",		ctypes.POINTER(ctypes.c_char)),
	("__src",		ctypes.POINTER(ctypes.c_char)),
	("__n",		ctypes.c_uint),] )

select = _rpythonic_function_(		"select", ctypes.c_int, [
	("__nfds",		ctypes.c_int),
	("__readfds",		ctypes.POINTER(fd_set)),
	("__writefds",		ctypes.POINTER(fd_set)),
	("__exceptfds",		ctypes.POINTER(fd_set)),
	("__timeout",		ctypes.POINTER(timeval)),] )

pselect = _rpythonic_function_(		"pselect", ctypes.c_int, [
	("__nfds",		ctypes.c_int),
	("__readfds",		ctypes.POINTER(fd_set)),
	("__writefds",		ctypes.POINTER(fd_set)),
	("__exceptfds",		ctypes.POINTER(fd_set)),
	("__timeout",		ctypes.POINTER(timespec)),
	("__sigmask",		ctypes.POINTER(__sigset_t)),] )

gnu_dev_major = _rpythonic_function_(		"gnu_dev_major", ctypes.c_uint, [
	("__dev",		ctypes.c_ulonglong),] )

gnu_dev_minor = _rpythonic_function_(		"gnu_dev_minor", ctypes.c_uint, [
	("__dev",		ctypes.c_ulonglong),] )

gnu_dev_makedev = _rpythonic_function_(		"gnu_dev_makedev", ctypes.c_ulonglong, [
	("__major",		ctypes.c_uint),
	("__minor",		ctypes.c_uint),] )

readv = _rpythonic_function_(		"readv", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__iovec",		ctypes.POINTER(iovec)),
	("__count",		ctypes.c_int),] )

writev = _rpythonic_function_(		"writev", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__iovec",		ctypes.POINTER(iovec)),
	("__count",		ctypes.c_int),] )

preadv = _rpythonic_function_(		"preadv", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__iovec",		ctypes.POINTER(iovec)),
	("__count",		ctypes.c_int),
	("__offset",		ctypes.c_int64),] )

pwritev = _rpythonic_function_(		"pwritev", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__iovec",		ctypes.POINTER(iovec)),
	("__count",		ctypes.c_int),
	("__offset",		ctypes.c_int64),] )

recvmmsg = _rpythonic_function_(		"recvmmsg", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__vmessages",		ctypes.POINTER(mmsghdr)),
	("__vlen",		ctypes.c_uint),
	("__flags",		ctypes.c_int),
	("__tmo",		ctypes.POINTER(timespec)),] )

socket = _rpythonic_function_(		"socket", ctypes.c_int, [
	("__domain",		ctypes.c_int),
	("__type",		ctypes.c_int),
	("__protocol",		ctypes.c_int),] )

socketpair = _rpythonic_function_(		"socketpair", ctypes.c_int, [
	("__domain",		ctypes.c_int),
	("__type",		ctypes.c_int),
	("__protocol",		ctypes.c_int),
	("__fds",		( ctypes.c_int * 2 )),] )

bind = _rpythonic_function_(		"bind", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__addr",		ctypes.POINTER(sockaddr)),
	("__len",		ctypes.c_uint),] )

tmpfile = _rpythonic_function_(		"tmpfile", ctypes.POINTER(_IO_FILE), [] )

tmpnam = _rpythonic_function_(		"tmpnam", ctypes.POINTER(ctypes.c_char), [
	("__s",		ctypes.POINTER(ctypes.c_char)),] )

tmpnam_r = _rpythonic_function_(		"tmpnam_r", ctypes.POINTER(ctypes.c_char), [
	("__s",		ctypes.POINTER(ctypes.c_char)),] )

tempnam = _rpythonic_function_(		"tempnam", ctypes.POINTER(ctypes.c_char), [
	("__dir",		ctypes.POINTER(ctypes.c_char)),
	("__pfx",		ctypes.POINTER(ctypes.c_char)),] )

fclose = _rpythonic_function_(		"fclose", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

fflush = _rpythonic_function_(		"fflush", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

fflush_unlocked = _rpythonic_function_(		"fflush_unlocked", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

fopen = _rpythonic_function_(		"fopen", ctypes.POINTER(_IO_FILE), [
	("__filename",		ctypes.POINTER(ctypes.c_char)),
	("__modes",		ctypes.POINTER(ctypes.c_char)),] )

freopen = _rpythonic_function_(		"freopen", ctypes.POINTER(_IO_FILE), [
	("__filename",		ctypes.POINTER(ctypes.c_char)),
	("__modes",		ctypes.POINTER(ctypes.c_char)),
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

fdopen = _rpythonic_function_(		"fdopen", ctypes.POINTER(_IO_FILE), [
	("__fd",		ctypes.c_int),
	("__modes",		ctypes.POINTER(ctypes.c_char)),] )

fmemopen = _rpythonic_function_(		"fmemopen", ctypes.POINTER(_IO_FILE), [
	("__s",		ctypes.POINTER(ctypes.c_void_p)),
	("__len",		ctypes.c_uint),
	("__modes",		ctypes.POINTER(ctypes.c_char)),] )

open_memstream = _rpythonic_function_(		"open_memstream", ctypes.POINTER(_IO_FILE), [
	("__bufloc",		ctypes.POINTER(ctypes.POINTER(ctypes.c_char))),
	("__sizeloc",		ctypes.POINTER(ctypes.c_uint)),] )

setbuf = _rpythonic_function_(		"setbuf", ctypes.c_void_p, [
	("__stream",		ctypes.POINTER(_IO_FILE)),
	("__buf",		ctypes.POINTER(ctypes.c_char)),] )

setvbuf = _rpythonic_function_(		"setvbuf", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),
	("__buf",		ctypes.POINTER(ctypes.c_char)),
	("__modes",		ctypes.c_int),
	("__n",		ctypes.c_uint),] )

setbuffer = _rpythonic_function_(		"setbuffer", ctypes.c_void_p, [
	("__stream",		ctypes.POINTER(_IO_FILE)),
	("__buf",		ctypes.POINTER(ctypes.c_char)),
	("__size",		ctypes.c_uint),] )

setlinebuf = _rpythonic_function_(		"setlinebuf", ctypes.c_void_p, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

fprintf = _rpythonic_function_(		"fprintf", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),
	("__format",		ctypes.POINTER(ctypes.c_char)),] )

_IO_seekoff = _rpythonic_function_(		"_IO_seekoff", ctypes.c_longlong, [
	("none",		ctypes.POINTER(ctypes.c_void_p)),
	("none",		ctypes.c_longlong),
	("none",		ctypes.c_int),
	("none",		ctypes.c_int),] )

_IO_seekpos = _rpythonic_function_(		"_IO_seekpos", ctypes.c_longlong, [
	("none",		ctypes.POINTER(ctypes.c_void_p)),
	("none",		ctypes.c_longlong),
	("none",		ctypes.c_int),] )

_IO_free_backup_area = _rpythonic_function_(		"_IO_free_backup_area", ctypes.c_void_p, [
	("none",		ctypes.POINTER(ctypes.c_void_p)),] )

remove = _rpythonic_function_(		"remove", ctypes.c_int, [
	("__filename",		ctypes.POINTER(ctypes.c_char)),] )

rename = _rpythonic_function_(		"rename", ctypes.c_int, [
	("__old",		ctypes.POINTER(ctypes.c_char)),
	("__new",		ctypes.POINTER(ctypes.c_char)),] )

renameat = _rpythonic_function_(		"renameat", ctypes.c_int, [
	("__oldfd",		ctypes.c_int),
	("__old",		ctypes.POINTER(ctypes.c_char)),
	("__newfd",		ctypes.c_int),
	("__new",		ctypes.POINTER(ctypes.c_char)),] )

printf = _rpythonic_function_(		"printf", ctypes.c_int, [
	("__format",		ctypes.POINTER(ctypes.c_char)),] )

sprintf = _rpythonic_function_(		"sprintf", ctypes.c_int, [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__format",		ctypes.POINTER(ctypes.c_char)),] )

vfprintf = _rpythonic_function_(		"vfprintf", ctypes.c_int, [
	("__s",		ctypes.POINTER(_IO_FILE)),
	("__format",		ctypes.POINTER(ctypes.c_char)),
	("__arg",		ctypes.c_char),] )

vprintf = _rpythonic_function_(		"vprintf", ctypes.c_int, [
	("__format",		ctypes.POINTER(ctypes.c_char)),
	("__arg",		ctypes.c_char),] )

vsprintf = _rpythonic_function_(		"vsprintf", ctypes.c_int, [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__format",		ctypes.POINTER(ctypes.c_char)),
	("__arg",		ctypes.c_char),] )

snprintf = _rpythonic_function_(		"snprintf", ctypes.c_int, [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__maxlen",		ctypes.c_uint),
	("__format",		ctypes.POINTER(ctypes.c_char)),] )

vsnprintf = _rpythonic_function_(		"vsnprintf", ctypes.c_int, [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__maxlen",		ctypes.c_uint),
	("__format",		ctypes.POINTER(ctypes.c_char)),
	("__arg",		ctypes.c_char),] )

vdprintf = _rpythonic_function_(		"vdprintf", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__fmt",		ctypes.POINTER(ctypes.c_char)),
	("__arg",		ctypes.c_char),] )

dprintf = _rpythonic_function_(		"dprintf", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__fmt",		ctypes.POINTER(ctypes.c_char)),] )

fscanf = _rpythonic_function_(		"fscanf", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),
	("__format",		ctypes.POINTER(ctypes.c_char)),] )

scanf = _rpythonic_function_(		"scanf", ctypes.c_int, [
	("__format",		ctypes.POINTER(ctypes.c_char)),] )

sscanf = _rpythonic_function_(		"sscanf", ctypes.c_int, [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__format",		ctypes.POINTER(ctypes.c_char)),] )

vfscanf = _rpythonic_function_(		"vfscanf", ctypes.c_int, [
	("__s",		ctypes.POINTER(_IO_FILE)),
	("__format",		ctypes.POINTER(ctypes.c_char)),
	("__arg",		ctypes.c_char),] )

vscanf = _rpythonic_function_(		"vscanf", ctypes.c_int, [
	("__format",		ctypes.POINTER(ctypes.c_char)),
	("__arg",		ctypes.c_char),] )

vsscanf = _rpythonic_function_(		"vsscanf", ctypes.c_int, [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__format",		ctypes.POINTER(ctypes.c_char)),
	("__arg",		ctypes.c_char),] )

fgetc = _rpythonic_function_(		"fgetc", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

getc = _rpythonic_function_(		"getc", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

getchar = _rpythonic_function_(		"getchar", ctypes.c_int, [] )

getc_unlocked = _rpythonic_function_(		"getc_unlocked", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

getchar_unlocked = _rpythonic_function_(		"getchar_unlocked", ctypes.c_int, [] )

fgetc_unlocked = _rpythonic_function_(		"fgetc_unlocked", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

fputc = _rpythonic_function_(		"fputc", ctypes.c_int, [
	("__c",		ctypes.c_int),
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

putc = _rpythonic_function_(		"putc", ctypes.c_int, [
	("__c",		ctypes.c_int),
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

putchar = _rpythonic_function_(		"putchar", ctypes.c_int, [
	("__c",		ctypes.c_int),] )

fputc_unlocked = _rpythonic_function_(		"fputc_unlocked", ctypes.c_int, [
	("__c",		ctypes.c_int),
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

putc_unlocked = _rpythonic_function_(		"putc_unlocked", ctypes.c_int, [
	("__c",		ctypes.c_int),
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

putchar_unlocked = _rpythonic_function_(		"putchar_unlocked", ctypes.c_int, [
	("__c",		ctypes.c_int),] )

getw = _rpythonic_function_(		"getw", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

putw = _rpythonic_function_(		"putw", ctypes.c_int, [
	("__w",		ctypes.c_int),
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

fgets = _rpythonic_function_(		"fgets", ctypes.POINTER(ctypes.c_char), [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__n",		ctypes.c_int),
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

gets = _rpythonic_function_(		"gets", ctypes.POINTER(ctypes.c_char), [
	("__s",		ctypes.POINTER(ctypes.c_char)),] )

getdelim = _rpythonic_function_(		"getdelim", ctypes.c_int, [
	("__lineptr",		ctypes.POINTER(ctypes.POINTER(ctypes.c_char))),
	("__n",		ctypes.POINTER(ctypes.c_uint)),
	("__delimiter",		ctypes.c_int),
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

getline = _rpythonic_function_(		"getline", ctypes.c_int, [
	("__lineptr",		ctypes.POINTER(ctypes.POINTER(ctypes.c_char))),
	("__n",		ctypes.POINTER(ctypes.c_uint)),
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

fputs = _rpythonic_function_(		"fputs", ctypes.c_int, [
	("__s",		ctypes.POINTER(ctypes.c_char)),
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

puts = _rpythonic_function_(		"puts", ctypes.c_int, [
	("__s",		ctypes.POINTER(ctypes.c_char)),] )

ungetc = _rpythonic_function_(		"ungetc", ctypes.c_int, [
	("__c",		ctypes.c_int),
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

fread = _rpythonic_function_(		"fread", ctypes.c_uint, [
	("__ptr",		ctypes.POINTER(ctypes.c_void_p)),
	("__size",		ctypes.c_uint),
	("__n",		ctypes.c_uint),
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

fwrite = _rpythonic_function_(		"fwrite", ctypes.c_uint, [
	("__ptr",		ctypes.POINTER(ctypes.c_void_p)),
	("__size",		ctypes.c_uint),
	("__n",		ctypes.c_uint),
	("__s",		ctypes.POINTER(_IO_FILE)),] )

fread_unlocked = _rpythonic_function_(		"fread_unlocked", ctypes.c_uint, [
	("__ptr",		ctypes.POINTER(ctypes.c_void_p)),
	("__size",		ctypes.c_uint),
	("__n",		ctypes.c_uint),
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

fwrite_unlocked = _rpythonic_function_(		"fwrite_unlocked", ctypes.c_uint, [
	("__ptr",		ctypes.POINTER(ctypes.c_void_p)),
	("__size",		ctypes.c_uint),
	("__n",		ctypes.c_uint),
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

fseek = _rpythonic_function_(		"fseek", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),
	("__off",		ctypes.c_int64),
	("__whence",		ctypes.c_int),] )

ftell = _rpythonic_function_(		"ftell", ctypes.c_int64, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

rewind = _rpythonic_function_(		"rewind", ctypes.c_void_p, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

fseeko = _rpythonic_function_(		"fseeko", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),
	("__off",		ctypes.c_int64),
	("__whence",		ctypes.c_int),] )

ftello = _rpythonic_function_(		"ftello", ctypes.c_int64, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

fgetpos = _rpythonic_function_(		"fgetpos", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),
	("__pos",		ctypes.POINTER(_G_fpos_t)),] )

fsetpos = _rpythonic_function_(		"fsetpos", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),
	("__pos",		ctypes.POINTER(_G_fpos_t)),] )

clearerr = _rpythonic_function_(		"clearerr", ctypes.c_void_p, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

feof = _rpythonic_function_(		"feof", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

ferror = _rpythonic_function_(		"ferror", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

clearerr_unlocked = _rpythonic_function_(		"clearerr_unlocked", ctypes.c_void_p, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

feof_unlocked = _rpythonic_function_(		"feof_unlocked", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

ferror_unlocked = _rpythonic_function_(		"ferror_unlocked", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

perror = _rpythonic_function_(		"perror", ctypes.c_void_p, [
	("__s",		ctypes.POINTER(ctypes.c_char)),] )

fileno = _rpythonic_function_(		"fileno", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

fileno_unlocked = _rpythonic_function_(		"fileno_unlocked", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

popen = _rpythonic_function_(		"popen", ctypes.POINTER(_IO_FILE), [
	("__command",		ctypes.POINTER(ctypes.c_char)),
	("__modes",		ctypes.POINTER(ctypes.c_char)),] )

pclose = _rpythonic_function_(		"pclose", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

ctermid = _rpythonic_function_(		"ctermid", ctypes.POINTER(ctypes.c_char), [
	("__s",		ctypes.POINTER(ctypes.c_char)),] )

flockfile = _rpythonic_function_(		"flockfile", ctypes.c_void_p, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

ftrylockfile = _rpythonic_function_(		"ftrylockfile", ctypes.c_int, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

funlockfile = _rpythonic_function_(		"funlockfile", ctypes.c_void_p, [
	("__stream",		ctypes.POINTER(_IO_FILE)),] )

memcpy = _rpythonic_function_(		"memcpy", ctypes.POINTER(ctypes.c_void_p), [
	("__dest",		ctypes.POINTER(ctypes.c_void_p)),
	("__src",		ctypes.POINTER(ctypes.c_void_p)),
	("__n",		ctypes.c_uint),] )

memmove = _rpythonic_function_(		"memmove", ctypes.POINTER(ctypes.c_void_p), [
	("__dest",		ctypes.POINTER(ctypes.c_void_p)),
	("__src",		ctypes.POINTER(ctypes.c_void_p)),
	("__n",		ctypes.c_uint),] )

memccpy = _rpythonic_function_(		"memccpy", ctypes.POINTER(ctypes.c_void_p), [
	("__dest",		ctypes.POINTER(ctypes.c_void_p)),
	("__src",		ctypes.POINTER(ctypes.c_void_p)),
	("__c",		ctypes.c_int),
	("__n",		ctypes.c_uint),] )

wiiuse_set_nunchuk_accel_threshold = _rpythonic_function_(		"wiiuse_set_nunchuk_accel_threshold", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("threshold",		ctypes.c_int),] )

wiiuse_set_wii_board_calib = _rpythonic_function_(		"wiiuse_set_wii_board_calib", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),] )

wiiuse_update_cb = _rpythonic_function_(		"wiiuse_update_cb", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(WiimoteState_t)),] )

wiiuse_update = _rpythonic_function_(		"wiiuse_update", ctypes.c_int, [
	("wm",		ctypes.POINTER(ctypes.POINTER(wiimote_t))),
	("wiimotes",		ctypes.c_int),
	("callback",		ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.POINTER(WiimoteState_t),)),] )

wiiuse_disconnect = _rpythonic_function_(		"wiiuse_disconnect", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),] )

wiiuse_poll = _rpythonic_function_(		"wiiuse_poll", ctypes.c_int, [
	("wm",		ctypes.POINTER(ctypes.POINTER(wiimote_t))),
	("wiimotes",		ctypes.c_int),] )

wiiuse_set_ir = _rpythonic_function_(		"wiiuse_set_ir", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("status",		ctypes.c_int),] )

wiiuse_set_ir_vres = _rpythonic_function_(		"wiiuse_set_ir_vres", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("x",		ctypes.c_uint),
	("y",		ctypes.c_uint),] )

wiiuse_set_ir_position = _rpythonic_function_(		"wiiuse_set_ir_position", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("pos",		ctypes.c_int),] )

wiiuse_set_aspect_ratio = _rpythonic_function_(		"wiiuse_set_aspect_ratio", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("aspect",		ctypes.c_int),] )

wiiuse_set_ir_sensitivity = _rpythonic_function_(		"wiiuse_set_ir_sensitivity", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("level",		ctypes.c_int),] )

wiiuse_set_nunchuk_orient_threshold = _rpythonic_function_(		"wiiuse_set_nunchuk_orient_threshold", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("threshold",		ctypes.c_float),] )

wiiuse_set_smooth_alpha = _rpythonic_function_(		"wiiuse_set_smooth_alpha", ctypes.c_float, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("alpha",		ctypes.c_float),] )

wiiuse_set_bluetooth_stack = _rpythonic_function_(		"wiiuse_set_bluetooth_stack", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(ctypes.POINTER(wiimote_t))),
	("wiimotes",		ctypes.c_int),
	("C_type",		ctypes.c_int),] )

wiiuse_set_orient_threshold = _rpythonic_function_(		"wiiuse_set_orient_threshold", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("threshold",		ctypes.c_float),] )

wiiuse_resync = _rpythonic_function_(		"wiiuse_resync", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),] )

wiiuse_set_timeout = _rpythonic_function_(		"wiiuse_set_timeout", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(ctypes.POINTER(wiimote_t))),
	("wiimotes",		ctypes.c_int),
	("normal_timeout",		ctypes.c_ubyte),
	("exp_timeout",		ctypes.c_ubyte),] )

wiiuse_set_accel_threshold = _rpythonic_function_(		"wiiuse_set_accel_threshold", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("threshold",		ctypes.c_int),] )

wiiuse_find = _rpythonic_function_(		"wiiuse_find", ctypes.c_int, [
	("wm",		ctypes.POINTER(ctypes.POINTER(wiimote_t))),
	("max_wiimotes",		ctypes.c_int),
	("timeout",		ctypes.c_int),] )

wiiuse_connect = _rpythonic_function_(		"wiiuse_connect", ctypes.c_int, [
	("wm",		ctypes.POINTER(ctypes.POINTER(wiimote_t))),
	("wiimotes",		ctypes.c_int),] )

wiiuse_set_leds = _rpythonic_function_(		"wiiuse_set_leds", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("leds",		ctypes.c_int),] )

wiiuse_motion_sensing = _rpythonic_function_(		"wiiuse_motion_sensing", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("status",		ctypes.c_int),] )

wiiuse_read_data = _rpythonic_function_(		"wiiuse_read_data", ctypes.c_int, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("buffer",		ctypes.POINTER(ctypes.c_ubyte)),
	("offset",		ctypes.c_uint),
	("C_len",		ctypes.c_uint16),] )

wiiuse_write_data = _rpythonic_function_(		"wiiuse_write_data", ctypes.c_int, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("addr",		ctypes.c_uint),
	("data",		ctypes.POINTER(ctypes.c_ubyte)),
	("C_len",		ctypes.c_ubyte),] )

wiiuse_status = _rpythonic_function_(		"wiiuse_status", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),] )

wiiuse_get_by_id = _rpythonic_function_(		"wiiuse_get_by_id", ctypes.POINTER(wiimote_t), [
	("wm",		ctypes.POINTER(ctypes.POINTER(wiimote_t))),
	("wiimotes",		ctypes.c_int),
	("unid",		ctypes.c_int),] )

wiiuse_set_flags = _rpythonic_function_(		"wiiuse_set_flags", ctypes.c_int, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("enable",		ctypes.c_int),
	("disable",		ctypes.c_int),] )

wiiuse_version = _rpythonic_function_(		"wiiuse_version", ctypes.POINTER(ctypes.c_char), [] )

wiiuse_set_output = _rpythonic_function_(		"wiiuse_set_output", ctypes.c_void_p, [
	("loglevel",		ctypes.c_int),
	("logtarget",		ctypes.POINTER(_IO_FILE)),] )

wiiuse_init = _rpythonic_function_(		"wiiuse_init", ctypes.POINTER(ctypes.POINTER(wiimote_t)), [
	("wiimotes",		ctypes.c_int),] )

wiiuse_disconnected = _rpythonic_function_(		"wiiuse_disconnected", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),] )

wiiuse_cleanup = _rpythonic_function_(		"wiiuse_cleanup", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(ctypes.POINTER(wiimote_t))),
	("wiimotes",		ctypes.c_int),] )

wiiuse_rumble = _rpythonic_function_(		"wiiuse_rumble", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("status",		ctypes.c_int),] )

wiiuse_toggle_rumble = _rpythonic_function_(		"wiiuse_toggle_rumble", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),] )

wiiuse_read_cb = _rpythonic_function_(		"wiiuse_read_cb", ctypes.c_void_p, [
	("wm",		ctypes.POINTER(wiimote_t)),
	("data",		ctypes.POINTER(ctypes.c_ubyte)),
	("C_len",		ctypes.c_uint16),] )

bachk = _rpythonic_function_(		"bachk", ctypes.c_int, [
	("C_str",		ctypes.POINTER(ctypes.c_char)),] )

baprintf = _rpythonic_function_(		"baprintf", ctypes.c_int, [
	("format",		ctypes.POINTER(ctypes.c_char)),] )

bafprintf = _rpythonic_function_(		"bafprintf", ctypes.c_int, [
	("stream",		ctypes.POINTER(_IO_FILE)),
	("format",		ctypes.POINTER(ctypes.c_char)),] )

basprintf = _rpythonic_function_(		"basprintf", ctypes.c_int, [
	("C_str",		ctypes.POINTER(ctypes.c_char)),
	("format",		ctypes.POINTER(ctypes.c_char)),] )

basnprintf = _rpythonic_function_(		"basnprintf", ctypes.c_int, [
	("C_str",		ctypes.POINTER(ctypes.c_char)),
	("size",		ctypes.c_uint),
	("format",		ctypes.POINTER(ctypes.c_char)),] )

bt_malloc = _rpythonic_function_(		"bt_malloc", ctypes.POINTER(ctypes.c_void_p), [
	("size",		ctypes.c_uint),] )

bt_free = _rpythonic_function_(		"bt_free", ctypes.c_void_p, [("ptr",		ctypes.c_void_p)] )

bt_error = _rpythonic_function_(		"bt_error", ctypes.c_int, [
	("code",		ctypes.c_uint16),] )

bt_compidtostr = _rpythonic_function_(		"bt_compidtostr", ctypes.POINTER(ctypes.c_char), [
	("C_id",		ctypes.c_int),] )

baswap = _rpythonic_function_(		"baswap", ctypes.c_void_p, [
	("dst",		ctypes.POINTER(bdaddr_t)),
	("src",		ctypes.POINTER(bdaddr_t)),] )

strtoba = _rpythonic_function_(		"strtoba", ctypes.POINTER(bdaddr_t), [
	("C_str",		ctypes.POINTER(ctypes.c_char)),] )

batostr = _rpythonic_function_(		"batostr", ctypes.POINTER(ctypes.c_char), [
	("ba",		ctypes.POINTER(bdaddr_t)),] )

ba2str = _rpythonic_function_(		"ba2str", ctypes.c_int, [
	("ba",		ctypes.POINTER(bdaddr_t)),
	("C_str",		ctypes.POINTER(ctypes.c_char)),] )

str2ba = _rpythonic_function_(		"str2ba", ctypes.c_int, [
	("C_str",		ctypes.POINTER(ctypes.c_char)),
	("ba",		ctypes.POINTER(bdaddr_t)),] )

ba2oui = _rpythonic_function_(		"ba2oui", ctypes.c_int, [
	("ba",		ctypes.POINTER(bdaddr_t)),
	("oui",		ctypes.POINTER(ctypes.c_char)),] )

ntohl = _rpythonic_function_(		"ntohl", ctypes.c_uint32, [
	("__netlong",		ctypes.c_uint32),] )

ntohs = _rpythonic_function_(		"ntohs", ctypes.c_uint16, [
	("__netshort",		ctypes.c_uint16),] )

htonl = _rpythonic_function_(		"htonl", ctypes.c_uint32, [
	("__hostlong",		ctypes.c_uint32),] )

htons = _rpythonic_function_(		"htons", ctypes.c_uint16, [
	("__hostshort",		ctypes.c_uint16),] )

bindresvport = _rpythonic_function_(		"bindresvport", ctypes.c_int, [
	("__sockfd",		ctypes.c_int),
	("__sock_in",		ctypes.POINTER(sockaddr_in)),] )

bindresvport6 = _rpythonic_function_(		"bindresvport6", ctypes.c_int, [
	("__sockfd",		ctypes.c_int),
	("__sock_in",		ctypes.POINTER(sockaddr_in6)),] )

accept = _rpythonic_function_(		"accept", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__addr",		ctypes.POINTER(sockaddr)),
	("__addr_len",		ctypes.POINTER(ctypes.c_uint)),] )

shutdown = _rpythonic_function_(		"shutdown", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__how",		ctypes.c_int),] )

sockatmark = _rpythonic_function_(		"sockatmark", ctypes.c_int, [
	("__fd",		ctypes.c_int),] )

isfdtype = _rpythonic_function_(		"isfdtype", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__fdtype",		ctypes.c_int),] )

recvfrom = _rpythonic_function_(		"recvfrom", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__buf",		ctypes.POINTER(ctypes.c_void_p)),
	("__n",		ctypes.c_uint),
	("__flags",		ctypes.c_int),
	("__addr",		ctypes.POINTER(sockaddr)),
	("__addr_len",		ctypes.POINTER(ctypes.c_uint)),] )

sendmsg = _rpythonic_function_(		"sendmsg", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__message",		ctypes.POINTER(msghdr)),
	("__flags",		ctypes.c_int),] )

recvmsg = _rpythonic_function_(		"recvmsg", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__message",		ctypes.POINTER(msghdr)),
	("__flags",		ctypes.c_int),] )

getsockopt = _rpythonic_function_(		"getsockopt", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__level",		ctypes.c_int),
	("__optname",		ctypes.c_int),
	("__optval",		ctypes.POINTER(ctypes.c_void_p)),
	("__optlen",		ctypes.POINTER(ctypes.c_uint)),] )

setsockopt = _rpythonic_function_(		"setsockopt", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__level",		ctypes.c_int),
	("__optname",		ctypes.c_int),
	("__optval",		ctypes.POINTER(ctypes.c_void_p)),
	("__optlen",		ctypes.c_uint),] )

listen = _rpythonic_function_(		"listen", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__n",		ctypes.c_int),] )

getsockname = _rpythonic_function_(		"getsockname", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__addr",		ctypes.POINTER(sockaddr)),
	("__len",		ctypes.POINTER(ctypes.c_uint)),] )

connect = _rpythonic_function_(		"connect", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__addr",		ctypes.POINTER(sockaddr)),
	("__len",		ctypes.c_uint),] )

getpeername = _rpythonic_function_(		"getpeername", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__addr",		ctypes.POINTER(sockaddr)),
	("__len",		ctypes.POINTER(ctypes.c_uint)),] )

send = _rpythonic_function_(		"send", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__buf",		ctypes.POINTER(ctypes.c_void_p)),
	("__n",		ctypes.c_uint),
	("__flags",		ctypes.c_int),] )

recv = _rpythonic_function_(		"recv", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__buf",		ctypes.POINTER(ctypes.c_void_p)),
	("__n",		ctypes.c_uint),
	("__flags",		ctypes.c_int),] )

sendto = _rpythonic_function_(		"sendto", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__buf",		ctypes.POINTER(ctypes.c_void_p)),
	("__n",		ctypes.c_uint),
	("__flags",		ctypes.c_int),
	("__addr",		ctypes.POINTER(sockaddr)),
	("__addr_len",		ctypes.c_uint),] )

_IO_getc = _rpythonic_function_(		"_IO_getc", ctypes.c_int, [
	("__fp",		ctypes.POINTER(_IO_FILE)),] )

_IO_putc = _rpythonic_function_(		"_IO_putc", ctypes.c_int, [
	("__c",		ctypes.c_int),
	("__fp",		ctypes.POINTER(_IO_FILE)),] )

_IO_ferror = _rpythonic_function_(		"_IO_ferror", ctypes.c_int, [
	("__fp",		ctypes.POINTER(_IO_FILE)),] )

_IO_feof = _rpythonic_function_(		"_IO_feof", ctypes.c_int, [
	("__fp",		ctypes.POINTER(_IO_FILE)),] )

_IO_peekc_locked = _rpythonic_function_(		"_IO_peekc_locked", ctypes.c_int, [
	("__fp",		ctypes.POINTER(_IO_FILE)),] )

_IO_sgetn = _rpythonic_function_(		"_IO_sgetn", ctypes.c_uint, [
	("none",		ctypes.POINTER(ctypes.c_void_p)),
	("none",		ctypes.POINTER(ctypes.c_void_p)),
	("none",		ctypes.c_uint),] )

_IO_flockfile = _rpythonic_function_(		"_IO_flockfile", ctypes.c_void_p, [
	("none",		ctypes.POINTER(ctypes.c_void_p)),] )

_IO_funlockfile = _rpythonic_function_(		"_IO_funlockfile", ctypes.c_void_p, [
	("none",		ctypes.POINTER(ctypes.c_void_p)),] )

_IO_ftrylockfile = _rpythonic_function_(		"_IO_ftrylockfile", ctypes.c_int, [
	("none",		ctypes.POINTER(ctypes.c_void_p)),] )

_IO_vfscanf = _rpythonic_function_(		"_IO_vfscanf", ctypes.c_int, [
	("__restrict",		ctypes.POINTER(_IO_FILE)),
	("__restrict",		ctypes.POINTER(ctypes.c_char)),
	("none",		ctypes.c_char),
	("__restrict",		ctypes.POINTER(ctypes.c_int)),] )

_IO_vfprintf = _rpythonic_function_(		"_IO_vfprintf", ctypes.c_int, [
	("__restrict",		ctypes.POINTER(_IO_FILE)),
	("__restrict",		ctypes.POINTER(ctypes.c_char)),
	("none",		ctypes.c_char),] )

_IO_padn = _rpythonic_function_(		"_IO_padn", ctypes.c_int, [
	("none",		ctypes.POINTER(ctypes.c_void_p)),
	("none",		ctypes.c_int),
	("none",		ctypes.c_int),] )


_rpythonic_convert_structs_to_objects()

def IS_PRESSED(dev, button): return ((dev.contents.buttons & button) == button)

def IS_HELD(dev, button): return ((dev.contents.buttons_held & button) == button)
      
def IS_RELEASED(dev, button): return  ((dev.contents.buttons_released & button) == button)

def IS_JUST_PRESSED(dev, button): return  (IS_PRESSED(dev, button) and not IS_HELD(dev, button))

def WIIUSE_USING_ACC(dev):  return ((dev.contents.state & 0x020) == 0x020)
  
def WIIUSE_USING_EXP(dev): return ((dev.contents.state & 0x040) == 0x040)
  
def WIIUSE_USING_IR(dev): return ((dev.contents.state & 0x080) == 0x080)
  
def WIIUSE_USING_SPEAKER(dev): return ((dev.contents.state & 0x100) == 0x100)

WIIUSE_SMOOTHING = 0x01
WIIUSE_CONTINUOUS = 0x02
WIIUSE_ORIENT_THRESH = 0x04
WIIUSE_INIT_FLAGS = (WIIUSE_SMOOTHING | WIIUSE_ORIENT_THRESH)

# from wiiuse_internal.h #
WIIMOTE_STATE_CONNECTED	= 0x0008
WIIMOTE_STATE_RUMBLE	= 0x0010
WIIMOTE_STATE_ACC = 0x0020
WIIMOTE_STATE_EXP = 0x0040
WIIMOTE_STATE_IR	= 0x0080
WIIMOTE_STATE_SPEAKER	 = 0x0100
WIIMOTE_STATE_IR_SENS_LVL1 = 0x0200
WIIMOTE_STATE_IR_SENS_LVL2 = 0x0400
WIIMOTE_STATE_IR_SENS_LVL3 = 0x0800
WIIMOTE_STATE_IR_SENS_LVL4 = 0x1000
WIIMOTE_STATE_IR_SENS_LVL5 = 0x2000
WIIMOTE_INIT_STATES = WIIMOTE_STATE_IR_SENS_LVL3

	
_rpythonic_setup_return_wrappers()
_rpythonic_make_nice_global_enums_()
_rpythonic_clean_up_missing_functions_()

################### Raymond Hettinger's Constant Folding ##################
# Decorator for BindingConstants at compile time
# A recipe by Raymond Hettinger, from Python Cookbook:
# http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/277940
# updated for Python3 and still compatible with Python2 - by Hart, May17th 2011

try: _BUILTINS_DICT_ = vars(__builtins__)
except: _BUILTINS_DICT_ = __builtins__
ISPYTHON2 = sys.version_info[0] == 2
_HETTINGER_FOLDS_ = 0

def _hettinger_make_constants(f, builtin_only=False, stoplist=[], verbose=0):
    from opcode import opmap, HAVE_ARGUMENT, EXTENDED_ARG
    global _HETTINGER_FOLDS_
    try:
        if ISPYTHON2: co = f.func_code; fname = f.func_name
        else: co = f.__code__; fname = f.__name__
    except AttributeError: return f        # Jython doesn't have a func_code attribute.
    if ISPYTHON2: newcode = map(ord, co.co_code)
    else: newcode = list( co.co_code )
    newconsts = list(co.co_consts)
    names = co.co_names
    codelen = len(newcode)
    if ISPYTHON2:
        if verbose >= 2: print( f.func_name )
        func_globals = f.func_globals
    else:
        if verbose >= 2: print( f.__name__ )
        func_globals = f.__globals__

    env = _BUILTINS_DICT_.copy()
    if builtin_only:
        stoplist = dict.fromkeys(stoplist)
        stoplist.update(func_globals)
    else:
        env.update(func_globals)

    # First pass converts global lookups into constants
    i = 0
    while i < codelen:
        opcode = newcode[i]
        if opcode in (EXTENDED_ARG, opmap['STORE_GLOBAL']):
            if verbose >= 1: print('skipping function', fname)
            return f    # for simplicity, only optimize common cases
        if opcode == opmap['LOAD_GLOBAL']:
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            name = co.co_names[oparg]
            if name in env and name not in stoplist:
                value = env[name]
                for pos, v in enumerate(newconsts):
                    if v is value:
                        break
                else:
                    pos = len(newconsts)
                    newconsts.append(value)
                newcode[i] = opmap['LOAD_CONST']
                newcode[i+1] = pos & 0xFF
                newcode[i+2] = pos >> 8
                _HETTINGER_FOLDS_ += 1
                if verbose >= 2:
                    print( "    global constant fold:", name )
        i += 1
        if opcode >= HAVE_ARGUMENT:
            i += 2

    # Second pass folds tuples of constants and constant attribute lookups
    i = 0
    while i < codelen:

        newtuple = []
        while newcode[i] == opmap['LOAD_CONST']:
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            newtuple.append(newconsts[oparg])
            i += 3

        opcode = newcode[i]
        if not newtuple:
            i += 1
            if opcode >= HAVE_ARGUMENT:
                i += 2
            continue

        if opcode == opmap['LOAD_ATTR']:
            obj = newtuple[-1]
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            name = names[oparg]
            try:
                value = getattr(obj, name)
                if verbose >= 2: print( '    folding attribute', name )
            except AttributeError:
                continue
            deletions = 1

        elif opcode == opmap['BUILD_TUPLE']:
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            if oparg != len(newtuple): continue
            deletions = len(newtuple)
            value = tuple(newtuple)

        else: continue

        reljump = deletions * 3
        newcode[i-reljump] = opmap['JUMP_FORWARD']
        newcode[i-reljump+1] = (reljump-3) & 0xFF
        newcode[i-reljump+2] = (reljump-3) >> 8

        n = len(newconsts)
        newconsts.append(value)
        newcode[i] = opmap['LOAD_CONST']
        newcode[i+1] = n & 0xFF
        newcode[i+2] = n >> 8
        i += 3
        _HETTINGER_FOLDS_ += 1
        if verbose >= 2:
            print( "    folded constant:",value )

    if ISPYTHON2:
        codestr = ''.join(map(chr, newcode))
        codeobj = type(co)(co.co_argcount, co.co_nlocals, co.co_stacksize,
                        co.co_flags, codestr, tuple(newconsts), co.co_names,
                        co.co_varnames, co.co_filename, co.co_name,
                        co.co_firstlineno, co.co_lnotab, co.co_freevars,
                        co.co_cellvars)
        return type(f)(codeobj, f.func_globals, f.func_name, f.func_defaults, f.func_closure)
    else:
        codestr = b''
        for s in newcode: codestr += s.to_bytes(1,'little')
        codeobj = type(co)(co.co_argcount, co.co_kwonlyargcount, co.co_nlocals, co.co_stacksize,
                        co.co_flags, codestr, tuple(newconsts), co.co_names,
                        co.co_varnames, co.co_filename, co.co_name,
                        co.co_firstlineno, co.co_lnotab, co.co_freevars,
                        co.co_cellvars)
        return type(f)(codeobj, f.__globals__, f.__name__, f.__defaults__, f.__closure__)


def hettinger_bind_recursive(mc, builtin_only=False, stoplist=[],  verbose=0):
    """Recursively apply constant binding to functions in a module or class.

    Use as the last line of the module (after everything is defined, but
    before test code).  In modules that need modifiable globals, set
    builtin_only to True.

    """
    import types
    try: d = vars(mc)
    except TypeError: return
    if ISPYTHON2: recursivetypes = (type, types.ClassType)
    else: recursivetypes = (type,)
    for k, v in d.items():
        if type(v) is types.FunctionType:
            newv = _hettinger_make_constants(v, builtin_only, stoplist,  verbose)
            setattr(mc, k, newv)
        elif type(v) in recursivetypes:
            hettinger_bind_recursive(v, builtin_only, stoplist, verbose)

def hettinger_transform( module=None ):
    global _HETTINGER_FOLDS_
    _HETTINGER_FOLDS_ = 0
    if not module: module = sys.modules[__name__]
    hettinger_bind_recursive( module, verbose=1 )
    print( 'HETTINGER: constants folded', _HETTINGER_FOLDS_ )
